<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'unsafe-inline'; style-src 'unsafe-inline'">
<title>EFT Lean Trainer</title>
<style>
/* === Reset & Base === */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg-primary: #1a1a2e;
  --bg-secondary: #16213e;
  --bg-tertiary: #0f3460;
  --accent-red: #e94560;
  --accent-turquoise: #16c79a;
  --accent-navy: #0f3460;
  --text-primary: #e0e0e0;
  --text-secondary: #8899aa;
  --text-muted: #556677;
  --key-bg: #2a2a4a;
  --key-border: #3a3a5a;
  --key-active: #e94560;
  --key-lean-left: #16c79a;
  --key-lean-right: #e94560;
  --panel-bg: rgba(22, 33, 62, 0.8);
  --panel-border: rgba(15, 52, 96, 0.6);
  --bg-darker: #111;
  --accent-yellow: #f0a500;
  --font-symbols: 'Segoe UI Symbol', 'Apple Symbols', 'Noto Sans Symbols 2', sans-serif;
}

html, body {
  height: 100%;
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: 'Courier New', 'Consolas', 'Monaco', monospace;
  overflow: hidden;
  user-select: none;
  -webkit-user-select: none;
}

/* === Layout === */
#app {
  display: flex;
  flex-direction: column;
  height: 100vh;
  max-width: 1200px;
  margin: 0 auto;
  padding: 8px 16px;
}

/* === Header === */
#header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid var(--panel-border);
  flex-shrink: 0;
}

#header h1 {
  font-size: 18px;
  font-weight: bold;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: var(--accent-red);
  text-shadow: 0 0 10px rgba(233, 69, 96, 0.3);
}

#header-controls {
  display: flex;
  align-items: center;
  gap: 12px;
}

.toggle-group {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.toggle-btn {
  padding: 4px 10px;
  font-size: 11px;
  font-family: var(--font-symbols);
  background: var(--key-bg);
  color: var(--text-secondary);
  border: 1px solid var(--key-border);
  cursor: pointer;
  transition: all 0.15s;
  letter-spacing: 1px;
}

.toggle-btn:first-of-type { border-radius: 3px 0 0 3px; }
.toggle-btn:last-of-type { border-radius: 0 3px 3px 0; }

.toggle-btn.active {
  background: var(--accent-navy);
  color: var(--accent-turquoise);
  border-color: var(--accent-turquoise);
}

.toggle-btn:focus-visible {
  outline: 2px solid var(--accent-turquoise);
  outline-offset: 2px;
}

#mode-select {
  padding: 4px 8px;
  font-size: 11px;
  font-family: inherit;
  background: var(--key-bg);
  color: var(--text-secondary);
  border: 1px solid var(--key-border);
  border-radius: 3px;
  cursor: pointer;
  letter-spacing: 1px;
  text-transform: uppercase;
}

#mode-select:focus { outline: 1px solid var(--accent-turquoise); }

/* === Main Area === */
#main {
  display: flex;
  flex-direction: column;
  flex: 1;
  gap: 8px;
  padding: 8px 0;
  min-height: 0;
}

/* === Canvas Area === */
#canvas-container {
  flex: 1;
  min-height: 200px;
  background: var(--bg-secondary);
  border: 1px solid var(--panel-border);
  border-radius: 4px;
  position: relative;
  overflow: hidden;
}

#game-canvas {
  display: block;
  width: 100%;
  height: 100%;
}

#canvas-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  color: var(--text-muted);
  font-size: 14px;
  letter-spacing: 2px;
  pointer-events: none;
}

/* === Bottom Panel === */
#bottom-panel {
  display: flex;
  gap: 12px;
  flex-shrink: 0;
}

/* === Key Indicators === */
#key-indicators {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  padding: 8px;
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 4px;
  flex-shrink: 0;
}

.key-row {
  display: flex;
  gap: 4px;
  justify-content: center;
}

.key {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--key-bg);
  border: 1px solid var(--key-border);
  border-radius: 4px;
  font-size: 18px;
  font-weight: bold;
  color: var(--text-secondary);
  transition: all 0.08s;
  text-shadow: none;
  font-family: var(--font-symbols);
}

.key.active {
  background: var(--key-active);
  border-color: var(--key-active);
  color: #fff;
  box-shadow: 0 0 12px rgba(233, 69, 96, 0.5);
  text-shadow: 0 0 4px rgba(255, 255, 255, 0.5);
}

.key.lean-left.active {
  background: var(--key-lean-left);
  border-color: var(--key-lean-left);
  box-shadow: 0 0 12px rgba(22, 199, 154, 0.5);
}

.key.lean-right.active {
  background: var(--key-lean-right);
  border-color: var(--key-lean-right);
  box-shadow: 0 0 12px rgba(233, 69, 96, 0.5);
}

#lean-state-display {
  font-size: 10px;
  letter-spacing: 1px;
  color: var(--text-muted);
  margin-top: 4px;
  min-height: 14px;
}

#lean-state-display.lean-left { color: var(--key-lean-left); }
#lean-state-display.lean-right { color: var(--key-lean-right); }

/* === Info Panel === */
#info-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
  min-width: 0;
}

#drill-panel {
  flex: 1;
  padding: 12px;
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 4px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
}

#drill-panel .placeholder {
  color: var(--text-muted);
  font-size: 12px;
  letter-spacing: 1px;
  text-transform: uppercase;
}

/* === Reaction Drill === */
.drill-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  margin-bottom: 8px;
  font-size: 11px;
  color: var(--text-secondary);
  letter-spacing: 1px;
  text-transform: uppercase;
}

.drill-level-tabs {
  display: flex;
  gap: 4px;
}

.drill-level-tab {
  padding: 3px 8px;
  font-size: 10px;
  font-family: inherit;
  background: var(--key-bg);
  color: var(--text-muted);
  border: 1px solid var(--key-border);
  border-radius: 3px;
  cursor: pointer;
  letter-spacing: 1px;
  text-transform: uppercase;
}

.drill-level-tab.active {
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border-color: var(--accent-turquoise);
}

.drill-level-tab.locked {
  opacity: 0.4;
  cursor: not-allowed;
}

.drill-prompt {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex: 1;
  width: 100%;
  gap: 8px;
}

.drill-prompt-keys {
  display: flex;
  gap: 8px;
  align-items: center;
  justify-content: center;
}

.drill-prompt-key {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 48px;
  height: 48px;
  font-size: 22px;
  font-weight: bold;
  font-family: var(--font-symbols);
  background: var(--key-bg);
  border: 2px solid var(--accent-turquoise);
  border-radius: 6px;
  color: var(--accent-turquoise);
  letter-spacing: 1px;
}

.drill-prompt-plus {
  font-size: 20px;
  color: var(--text-muted);
}

.drill-prompt-instruction {
  font-size: 11px;
  color: var(--text-secondary);
  letter-spacing: 1px;
  text-transform: uppercase;
}

.drill-reaction-time {
  font-size: 28px;
  font-weight: bold;
  color: var(--accent-turquoise);
  letter-spacing: 2px;
}

.drill-reaction-time.slow {
  color: var(--accent-red);
}

.drill-progress {
  font-size: 10px;
  color: var(--text-muted);
  letter-spacing: 1px;
}

.drill-result {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  width: 100%;
}

.drill-result-title {
  font-size: 14px;
  font-weight: bold;
  color: var(--text-primary);
  letter-spacing: 2px;
  text-transform: uppercase;
}

.drill-result-stats {
  display: flex;
  gap: 24px;
  font-size: 12px;
  color: var(--text-secondary);
}

.drill-result-stat {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}

.drill-result-stat-value {
  font-size: 20px;
  font-weight: bold;
  color: var(--accent-turquoise);
}

.drill-result-stat-label {
  font-size: 9px;
  color: var(--text-muted);
  letter-spacing: 1px;
  text-transform: uppercase;
}

.drill-btn {
  padding: 6px 16px;
  font-size: 11px;
  font-family: inherit;
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border: 1px solid var(--accent-turquoise);
  border-radius: 3px;
  cursor: pointer;
  letter-spacing: 1px;
  text-transform: uppercase;
  transition: all 0.15s;
}

.drill-btn:hover {
  background: var(--accent-turquoise);
  color: var(--bg-primary);
}

.drill-btn-group {
  display: flex;
  gap: 8px;
  margin-top: 4px;
}

.drill-level-up {
  font-size: 12px;
  color: var(--accent-turquoise);
  letter-spacing: 1px;
  text-transform: uppercase;
  animation: drill-pulse 1s ease-in-out 3;
}

@keyframes drill-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.drill-kro-warning {
  padding: 6px 10px;
  background: rgba(233, 69, 96, 0.15);
  border: 1px solid rgba(233, 69, 96, 0.3);
  border-radius: 4px;
  color: var(--accent-red);
  font-size: 10px;
  letter-spacing: 0.5px;
  width: 100%;
  text-align: center;
}

.drill-countdown {
  font-size: 48px;
  font-weight: bold;
  color: var(--text-primary);
  letter-spacing: 4px;
}

.drill-prompt-key.active {
  border-color: var(--accent-red);
  color: var(--accent-red);
}

.drill-panel-idle {
  gap: 8px;
}

#settings-bar {
  padding: 8px 12px;
  background: var(--panel-bg);
  border: 1px solid var(--panel-border);
  border-radius: 4px;
  font-size: 11px;
  font-family: var(--font-symbols);
  color: var(--text-muted);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.settings-btn {
  padding: 4px 10px;
  font-size: 10px;
  font-family: inherit;
  background: var(--key-bg);
  color: var(--text-secondary);
  border: 1px solid var(--key-border);
  border-radius: 3px;
  cursor: pointer;
  letter-spacing: 1px;
  text-transform: uppercase;
  transition: all 0.15s;
}

.settings-btn:hover {
  background: var(--bg-tertiary);
  border-color: var(--accent-turquoise);
  color: var(--text-primary);
}

.settings-btn.danger {
  border-color: rgba(233, 69, 96, 0.4);
}

.settings-btn.danger:hover {
  background: rgba(233, 69, 96, 0.15);
  border-color: var(--accent-red);
  color: var(--accent-red);
}

.settings-btn:focus-visible {
  outline: 2px solid var(--accent-turquoise);
  outline-offset: 2px;
}

/* === KRO Diagnostic Overlay === */
#kro-diagnostic {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(10, 10, 25, 0.95);
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 20px;
  z-index: 100;
  padding: 24px;
}

#kro-diagnostic.active { display: flex; }

.kro-title {
  font-size: 16px;
  font-weight: bold;
  color: var(--accent-turquoise);
  letter-spacing: 4px;
  text-transform: uppercase;
}

.kro-instruction {
  font-size: 13px;
  color: var(--text-secondary);
  text-align: center;
  max-width: 400px;
  line-height: 1.6;
}

.kro-key-display {
  display: flex;
  gap: 10px;
  align-items: center;
}

.kro-key {
  width: 56px;
  height: 56px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  font-weight: bold;
  background: var(--key-bg);
  border: 2px solid var(--key-border);
  border-radius: 6px;
  color: var(--text-secondary);
  transition: all 0.1s;
}

.kro-key.detected {
  background: var(--accent-turquoise);
  border-color: var(--accent-turquoise);
  color: var(--bg-primary);
  box-shadow: 0 0 12px rgba(22, 199, 154, 0.5);
}

.kro-key.failed {
  border-color: var(--accent-red);
  color: var(--accent-red);
}

.kro-plus {
  font-size: 20px;
  color: var(--text-muted);
}

.kro-status {
  font-size: 12px;
  color: var(--text-muted);
  letter-spacing: 1px;
}

.kro-result {
  text-align: center;
  display: flex;
  flex-direction: column;
  gap: 12px;
  align-items: center;
}

.kro-result-hidden { display: none; }

.kro-result-title {
  font-size: 14px;
  font-weight: bold;
  color: var(--text-primary);
  letter-spacing: 2px;
  text-transform: uppercase;
}

.kro-result-max {
  font-size: 32px;
  font-weight: bold;
  color: var(--accent-turquoise);
}

.kro-result-note {
  font-size: 10px;
  color: var(--text-muted);
  max-width: 350px;
  text-align: center;
  line-height: 1.5;
}

.kro-failed-combos {
  font-size: 11px;
  color: var(--accent-red);
  text-align: center;
}

.kro-close-btn {
  padding: 8px 24px;
  font-size: 12px;
  font-family: inherit;
  background: var(--bg-tertiary);
  color: var(--accent-turquoise);
  border: 1px solid var(--accent-turquoise);
  border-radius: 4px;
  cursor: pointer;
  letter-spacing: 2px;
  text-transform: uppercase;
  transition: all 0.15s;
}

.kro-close-btn:hover {
  background: var(--accent-turquoise);
  color: var(--bg-primary);
}

.kro-close-btn:focus-visible {
  outline: 2px solid var(--accent-turquoise);
  outline-offset: 2px;
}

/* === Status Bar === */
#status-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 4px 0;
  border-top: 1px solid var(--panel-border);
  flex-shrink: 0;
  font-size: 10px;
  color: var(--text-muted);
  letter-spacing: 1px;
  text-transform: uppercase;
}

/* === Warning Banner === */
#warning-banner {
  display: none;
  padding: 6px 12px;
  background: rgba(233, 69, 96, 0.15);
  border: 1px solid rgba(233, 69, 96, 0.3);
  border-radius: 4px;
  color: var(--accent-red);
  font-size: 11px;
  text-align: center;
}

#warning-banner.visible { display: block; }

/* === Warmup Guide Overlay === */
#warmup-guide {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(10, 10, 25, 0.92);
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 16px;
  z-index: 10;
}
#warmup-guide.active { display: flex; }
#warmup-guide .warmup-title {
  font-size: 16px;
  color: var(--accent-turquoise);
  letter-spacing: 4px;
  text-transform: uppercase;
}
#warmup-guide .warmup-key-display {
  width: 72px;
  height: 72px;
  border: 3px solid var(--accent-turquoise);
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
  font-weight: bold;
  font-family: var(--font-symbols);
  color: var(--accent-turquoise);
  transition: all 0.15s;
}
#warmup-guide .warmup-key-display.pressed {
  background: var(--accent-turquoise);
  color: var(--bg-primary);
}
#warmup-guide .warmup-desc {
  font-size: 13px;
  color: var(--text-secondary);
  text-align: center;
}
#warmup-guide .warmup-hint {
  font-size: 11px;
  color: var(--text-muted);
}
#warmup-guide .warmup-progress {
  display: flex;
  gap: 6px;
}
#warmup-guide .warmup-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--panel-border);
}
#warmup-guide .warmup-dot.done { background: var(--accent-turquoise); }
#warmup-guide .warmup-dot.current {
  background: var(--accent-turquoise);
  box-shadow: 0 0 6px var(--accent-turquoise);
}
#warmup-guide .warmup-skip {
  margin-top: 8px;
  background: transparent;
  border: 1px solid var(--text-muted);
  color: var(--text-secondary);
  padding: 5px 14px;
  cursor: pointer;
  font-family: inherit;
  font-size: 10px;
  letter-spacing: 2px;
  border-radius: 3px;
}
#warmup-guide .warmup-skip:hover {
  border-color: var(--text-secondary);
  color: var(--text-primary);
}

/* === Free Practice Drill Panel === */
.free-practice-info { padding: 8px 0; }
.free-practice-info .fp-title {
  font-size: 13px;
  font-weight: bold;
  color: var(--accent-turquoise);
  margin-bottom: 6px;
  letter-spacing: 1px;
}
.free-practice-info .fp-controls {
  font-size: 11px;
  color: var(--text-secondary);
  line-height: 1.6;
}
.free-practice-info .fp-legend {
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 6px;
  line-height: 1.5;
}
.fp-legend-visible { color: var(--accent-turquoise); }
.fp-legend-blocked { color: var(--accent-red); }

/* === Combo Drill === */
.combo-technique-list { display: flex; flex-direction: column; gap: 6px; padding: 4px 0; }
.combo-technique-card {
  display: flex; align-items: center; gap: 10px;
  background: var(--bg-secondary); border: 1px solid var(--key-border);
  border-radius: 4px; padding: 8px 10px; cursor: pointer;
  transition: border-color 0.2s, background 0.2s;
}
.combo-technique-card:hover:not(.locked) {
  border-color: var(--accent-turquoise); background: var(--bg-tertiary);
}
.combo-technique-card.selected {
  border-color: var(--accent-turquoise); background: var(--bg-tertiary);
}
.combo-technique-card.locked {
  opacity: 0.4; cursor: not-allowed;
}
.drill-btn-secondary { margin-top: 4px; opacity: 0.7; }
.combo-technique-name {
  font-size: 12px; font-weight: bold; color: var(--text-primary);
  letter-spacing: 1px;
}
.combo-technique-rate {
  font-size: 10px; color: var(--text-muted); margin-left: auto;
}
.combo-technique-lock {
  font-size: 10px; color: var(--text-muted); margin-left: auto;
}
.combo-description {
  font-size: 10px; color: var(--text-secondary); padding: 4px 0;
  line-height: 1.5;
}
.combo-demo-area {
  background: var(--bg-primary); border: 1px solid var(--key-border);
  border-radius: 4px; padding: 8px; margin: 6px 0; min-height: 40px;
  display: flex; align-items: center; justify-content: center; gap: 4px;
  flex-wrap: wrap;
}
.combo-demo-step {
  display: inline-flex; align-items: center; gap: 3px;
  padding: 3px 6px; border-radius: 3px; font-size: 11px;
  font-family: var(--font-symbols);
  background: var(--bg-secondary); color: var(--text-secondary);
  border: 1px solid transparent; transition: all 0.2s;
}
.combo-demo-step.active {
  background: var(--bg-tertiary); color: var(--accent-turquoise);
  border-color: var(--accent-turquoise);
}
.combo-demo-step.done {
  background: var(--bg-secondary); color: var(--text-muted);
  opacity: 0.5;
}
.combo-demo-step .step-action {
  font-size: 9px; text-transform: uppercase; letter-spacing: 1px;
  color: var(--text-muted);
}
.combo-demo-step .step-keys {
  font-weight: bold; letter-spacing: 1px;
}
.combo-demo-arrow { color: var(--text-muted); font-size: 10px; }
.combo-repeat-indicator {
  font-size: 10px; color: var(--text-muted); text-align: center;
  padding: 2px 0; letter-spacing: 1px;
}
.combo-step-progress {
  display: flex; gap: 3px; justify-content: center; padding: 6px 0;
}
.combo-step-dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: var(--key-border); transition: background 0.2s;
}
.combo-step-dot.done { background: var(--accent-turquoise); }
.combo-step-dot.active { background: var(--accent-red); box-shadow: 0 0 6px var(--accent-red); }
.combo-step-dot.fail { background: var(--accent-red); opacity: 0.5; }
.combo-feedback {
  font-size: 14px; font-weight: bold; text-align: center;
  padding: 8px 0; letter-spacing: 2px;
}
.combo-feedback.success { color: var(--accent-turquoise); }
.combo-feedback.fail { color: var(--accent-red); }
.combo-result-stats {
  display: flex; gap: 12px; justify-content: center; padding: 6px 0;
}
.combo-result-stat { text-align: center; }
.combo-result-stat-value {
  font-size: 18px; font-weight: bold; color: var(--accent-turquoise);
}
.combo-result-stat-label {
  font-size: 10px; color: var(--text-muted); letter-spacing: 1px;
}
.combo-unlock-msg {
  font-size: 11px; color: var(--accent-turquoise); text-align: center;
  padding: 4px 0; letter-spacing: 1px;
  animation: drill-pulse 1s ease-in-out infinite;
}
/* Rhythm Drill */
.rhythm-bpm-container {
  display: flex; flex-direction: column; gap: 4px; padding: 8px 0;
}
.rhythm-bpm-label {
  font-size: 13px; color: var(--text-primary); letter-spacing: 1px;
  font-weight: bold;
}
.rhythm-bpm-slider {
  width: 100%; accent-color: var(--accent-turquoise); cursor: pointer;
}
.rhythm-bpm-slider:disabled { opacity: 0.4; cursor: not-allowed; }
.rhythm-max-bpm {
  font-size: 11px; color: var(--text-muted); text-align: center;
  padding: 4px 0; letter-spacing: 1px;
}
.rhythm-progressive-container {
  display: flex; align-items: center; gap: 6px; padding: 4px 0;
  font-size: 11px; color: var(--text-muted);
}
.rhythm-progressive-container input[type="checkbox"] {
  accent-color: var(--accent-turquoise);
}
.rhythm-beat-progress {
  font-size: 11px; color: var(--text-muted); text-align: center;
  padding: 4px 0; letter-spacing: 2px;
}
.rhythm-feedback {
  font-size: 16px; font-weight: bold; text-align: center;
  padding: 6px 0; letter-spacing: 2px; min-height: 24px;
  transition: opacity 0.3s ease;
}
.rhythm-score {
  font-size: 11px; color: var(--text-muted); text-align: center;
  padding: 4px 0; letter-spacing: 1px;
}
.rhythm-breakdown {
  display: flex; gap: 12px; justify-content: center;
  font-size: 12px; padding: 6px 0; letter-spacing: 1px;
}
.rhythm-advance-msg {
  font-size: 13px; color: var(--accent-turquoise); text-align: center;
  padding: 6px 0; font-weight: bold; letter-spacing: 2px;
  animation: drill-pulse 1s ease-in-out infinite;
}
.rhythm-beat-indicator {
  height: 4px; background: var(--bg-darker); border-radius: 2px;
  margin-top: 6px; overflow: hidden; position: relative;
}
.rhythm-beat-indicator .beat-flash {
  position: absolute; inset: 0; background: var(--accent-turquoise);
  opacity: 0; transition: opacity 0.05s ease;
}
.rhythm-beat-indicator .beat-flash.active { opacity: 1; }
</style>
</head>
<body>

<div id="app">
  <!-- Warning Banner (for schema version mismatch etc.) -->
  <div id="warning-banner"></div>

  <!-- Header -->
  <header id="header">
    <h1>EFT Lean Trainer</h1>
    <div id="header-controls">
      <div class="toggle-group">
        <span>Lean:</span>
        <button class="toggle-btn active" data-lean-mode="hold">Hold</button>
        <button class="toggle-btn" data-lean-mode="toggle">Toggle</button>
      </div>
      <div class="toggle-group" role="group" aria-label="リーン方向">
        <span>Layout:</span>
        <button class="toggle-btn active" data-lean-dir="reversed" aria-pressed="true">↷右 ↶左</button>
        <button class="toggle-btn" data-lean-dir="standard" aria-pressed="false">EFT標準</button>
      </div>
      <select id="mode-select">
        <option value="free">Free Practice</option>
        <option value="reaction">Key Reaction</option>
        <option value="combo">Combo Drill</option>
        <option value="rhythm">Rhythm Drill</option>
      </select>
    </div>
  </header>

  <!-- Main Area -->
  <div id="main">
    <!-- Canvas -->
    <div id="canvas-container">
      <canvas id="game-canvas" role="img" aria-label="リーン練習シミュレーション"></canvas>
      <div id="canvas-overlay">AWAITING RENDERER</div>
      <!-- Warmup Guide (shown on first free practice entry) -->
      <div id="warmup-guide">
        <div class="warmup-title">WARMUP GUIDE</div>
        <div class="warmup-key-display" id="warmup-key"></div>
        <div class="warmup-desc" id="warmup-desc"></div>
        <div class="warmup-hint" id="warmup-hint">Press the key to continue</div>
        <div class="warmup-progress" id="warmup-progress"></div>
        <button class="warmup-skip" id="warmup-skip">SKIP</button>
      </div>
    </div>

    <!-- Bottom: Key Indicators + Info Panel -->
    <div id="bottom-panel">
      <!-- Key Indicators -->
      <div id="key-indicators">
        <div class="key-row">
          <div class="key" data-key="KeyQ" aria-label="リーン">↶</div>
          <div class="key" data-key="KeyW" aria-label="前進">↑</div>
          <div class="key" data-key="KeyE" aria-label="リーン">↷</div>
        </div>
        <div class="key-row">
          <div class="key" data-key="KeyA" aria-label="左移動">←</div>
          <div class="key" data-key="KeyS" aria-label="後退">↓</div>
          <div class="key" data-key="KeyD" aria-label="右移動">→</div>
        </div>
        <div id="lean-state-display">NEUTRAL</div>
      </div>

      <!-- Info Panel -->
      <div id="info-panel">
        <div id="drill-panel">
          <div class="placeholder">Select a mode to begin</div>
        </div>
        <div id="settings-bar">
          <span>移動: ↑←↓→ / リーン: ↶↷</span>
          <span id="clock-display">0.000s</span>
          <button class="settings-btn" id="btn-kro-diagnostic">KBD Diag</button>
          <button class="settings-btn danger" id="btn-data-reset">Reset</button>
        </div>
      </div>
    </div>
  </div>

  <!-- KRO Diagnostic Overlay -->
  <div id="kro-diagnostic" role="dialog" aria-modal="true" aria-label="キーボード診断">
    <h2 class="kro-title">KEYBOARD DIAGNOSTIC</h2>
    <div class="kro-instruction" id="kro-instruction"></div>
    <div class="kro-key-display" id="kro-key-display"></div>
    <div class="kro-status" id="kro-status"></div>
    <div class="kro-result kro-result-hidden" id="kro-result"></div>
    <button class="kro-close-btn" id="kro-close">CLOSE</button>
  </div>

  <!-- Status Bar -->
  <div id="status-bar">
    <span id="status-mode">Mode: Free Practice</span>
    <span id="status-keys">Keys: 0</span>
    <span id="status-lean">Lean: Neutral</span>
  </div>
</div>

<script>
// ============================================================
// GameClock — performance.now() based time management
// ============================================================
class GameClock {
  constructor() {
    this._startTime = performance.now();
  }

  now() {
    return performance.now();
  }

  elapsed() {
    return performance.now() - this._startTime;
  }

  reset() {
    this._startTime = performance.now();
  }
}

// ============================================================
// InputManager — Key input and lean state management
// ============================================================
class InputManager {
  constructor() {
    this.pressedKeys = new Set();
    this.leanState = 'neutral';
    this.leanMode = 'hold';
    this.useEftStandard = false;
    this._keyToLean = { KeyQ: 'right', KeyE: 'left' };
    this._listeners = {};
    this._keyPressTimestamps = new Map();
    this.SIMULTANEOUS_WINDOW = 80;
    this.GAME_KEYS = new Set([
      'KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyQ', 'KeyE', 'Space', 'Escape'
    ]);

    this._onKeyDown = this._handleKeyDown.bind(this);
    this._onKeyUp = this._handleKeyUp.bind(this);
    this._onBlur = this._handleBlur.bind(this);
    this._onVisibilityChange = this._handleVisibilityChange.bind(this);

    document.addEventListener('keydown', this._onKeyDown);
    document.addEventListener('keyup', this._onKeyUp);
    window.addEventListener('blur', this._onBlur);
    document.addEventListener('visibilitychange', this._onVisibilityChange);
  }

  _handleKeyDown(e) {
    if (e.repeat) return;

    const active = document.activeElement;
    const isInput = active && (
      active.tagName === 'INPUT' ||
      active.tagName === 'TEXTAREA' ||
      active.tagName === 'SELECT'
    );

    if (this.GAME_KEYS.has(e.code) && !isInput) {
      e.preventDefault();
    }

    this.pressedKeys.add(e.code);
    this._keyPressTimestamps.set(e.code, performance.now());

    this._updateLeanState(e.code, 'keydown');
    this._emit('keydown', {
      code: e.code,
      pressedKeys: new Set(this.pressedKeys),
      leanState: this.leanState
    });
  }

  _handleKeyUp(e) {
    this.pressedKeys.delete(e.code);
    this._keyPressTimestamps.delete(e.code);

    this._updateLeanState(e.code, 'keyup');
    this._emit('keyup', {
      code: e.code,
      pressedKeys: new Set(this.pressedKeys),
      leanState: this.leanState
    });
  }

  _updateLeanState(code, eventType) {
    if (code !== 'KeyQ' && code !== 'KeyE') return;

    const prevState = this.leanState;
    const leanDir = this._keyToLean[code];
    const otherKey = code === 'KeyQ' ? 'KeyE' : 'KeyQ';
    const otherDir = this._keyToLean[otherKey];

    if (this.leanMode === 'hold') {
      if (eventType === 'keydown') {
        this.leanState = leanDir;
      } else {
        this.leanState = this.pressedKeys.has(otherKey) ? otherDir : 'neutral';
      }
    } else {
      if (eventType === 'keydown') {
        this.leanState = this.leanState === leanDir ? 'neutral' : leanDir;
      }
    }

    if (prevState !== this.leanState) {
      this._emit('leanchange', { prevState, newState: this.leanState });
    }
  }

  _handleBlur() {
    this.resetState();
  }

  _handleVisibilityChange() {
    if (document.hidden) this.resetState();
  }

  resetState() {
    this.pressedKeys.clear();
    this._keyPressTimestamps.clear();
    const prevState = this.leanState;
    this.leanState = 'neutral';
    if (prevState !== 'neutral') {
      this._emit('leanchange', { prevState, newState: 'neutral' });
    }
    this._emit('reset', {});
  }

  on(event, cb) {
    if (!this._listeners[event]) this._listeners[event] = [];
    this._listeners[event].push(cb);
  }

  off(event, cb) {
    if (!this._listeners[event]) return;
    this._listeners[event] = this._listeners[event].filter(fn => fn !== cb);
  }

  _emit(event, data) {
    const cbs = this._listeners[event];
    if (!cbs) return;
    for (let i = 0; i < cbs.length; i++) cbs[i](data);
  }

  getKeyPressTime(code) {
    return this._keyPressTimestamps.get(code) || null;
  }

  areSimultaneous(codes) {
    if (codes.length === 0) return false;
    const times = [];
    for (let i = 0; i < codes.length; i++) {
      const t = this._keyPressTimestamps.get(codes[i]);
      if (t == null) return false;
      times.push(t);
    }
    return Math.max(...times) - Math.min(...times) <= this.SIMULTANEOUS_WINDOW;
  }

  setLeanMode(mode) {
    this.leanMode = mode;
    this.resetState();
  }

  setLeanDirection(useEftStandard) {
    this.useEftStandard = !!useEftStandard;
    this._keyToLean = useEftStandard
      ? { KeyQ: 'left', KeyE: 'right' }
      : { KeyQ: 'right', KeyE: 'left' };
    this.resetState();
    this._updateKeyIndicatorClasses();
  }

  _updateKeyIndicatorClasses() {
    const qEl = document.querySelector('.key[data-key="KeyQ"]');
    const eEl = document.querySelector('.key[data-key="KeyE"]');
    if (!qEl || !eEl) return;
    qEl.classList.remove('lean-left', 'lean-right');
    eEl.classList.remove('lean-left', 'lean-right');
    qEl.classList.add('lean-' + this._keyToLean.KeyQ);
    eEl.classList.add('lean-' + this._keyToLean.KeyE);
    qEl.textContent = this.getKeySymbol('KeyQ');
    eEl.textContent = this.getKeySymbol('KeyE');
    const qDir = this._keyToLean.KeyQ === 'right' ? '右リーン' : '左リーン';
    const eDir = this._keyToLean.KeyE === 'right' ? '右リーン' : '左リーン';
    qEl.setAttribute('aria-label', qDir);
    eEl.setAttribute('aria-label', eDir);
  }

  getKeySymbol(keyCode) {
    if (InputManager._MOVE_SYMBOLS[keyCode]) return InputManager._MOVE_SYMBOLS[keyCode];
    if (keyCode === 'KeyQ') return this._keyToLean.KeyQ === 'right' ? '↷' : '↶';
    if (keyCode === 'KeyE') return this._keyToLean.KeyE === 'right' ? '↷' : '↶';
    return keyCode;
  }

  getLeanKeyForDirection(direction) {
    if (direction === 'left') return this._keyToLean.KeyQ === 'left' ? 'KeyQ' : 'KeyE';
    if (direction === 'right') return this._keyToLean.KeyQ === 'right' ? 'KeyQ' : 'KeyE';
    return null;
  }

  destroy() {
    document.removeEventListener('keydown', this._onKeyDown);
    document.removeEventListener('keyup', this._onKeyUp);
    window.removeEventListener('blur', this._onBlur);
    document.removeEventListener('visibilitychange', this._onVisibilityChange);
  }
}
InputManager._MOVE_SYMBOLS = { KeyW: '↑', KeyA: '←', KeyS: '↓', KeyD: '→' };

// ============================================================
// Storage — localStorage with schema versioning & fallback
// ============================================================
class Storage {
  constructor() {
    this.KEY = 'eft-lean-trainer';
    this.BACKUP_PREFIX = 'eft-lean-trainer-backup-';
    this.MAX_BACKUPS = 3;
    this.CURRENT_VERSION = 2;

    this.DEFAULTS = {
      schemaVersion: 2,
      settings: { leanMode: 'hold', useEftStandard: false },
      reactionDrill: { levels: {}, best: {} },
      comboDrill: { techniques: {}, unlocked: ['jiggle_right'] },
      rhythmDrill: { maxBPM: 60, perfectRate: 0 },
      kro: { diagnosis: null, failedCombos: {}, drillFailCounts: {} }
    };

    this.MIGRATIONS = {
      1: function(data) {
        if (!data.settings) data.settings = {};
        if (data.settings.useEftStandard === undefined) {
          data.settings.useEftStandard = false;
        }
        data.schemaVersion = 2;
        return data;
      }
    };
  }

  load() {
    try {
      const raw = localStorage.getItem(this.KEY);
      if (!raw) return this._deepClone(this.DEFAULTS);

      const data = JSON.parse(raw);
      if (!data || typeof data !== 'object' ||
          typeof data.schemaVersion !== 'number' ||
          !Number.isInteger(data.schemaVersion) ||
          data.schemaVersion < 1) {
        throw new Error('Invalid schema: schemaVersion must be a positive integer');
      }
      return this.migrate(data);
    } catch (e) {
      console.warn('[Storage] Data corrupted, backing up and reinitializing:', e);
      this._backupCorrupted();
      const defaults = this._deepClone(this.DEFAULTS);
      this.save(defaults);
      this._notifyUser('データが破損していたため初期化しました。設定はリセットされています。');
      return defaults;
    }
  }

  save(data) {
    if (data._readOnly) {
      console.warn('[Storage] Data is read-only (future schema version). Skipping save.');
      return;
    }
    try {
      localStorage.setItem(this.KEY, JSON.stringify(data));
    } catch (e) {
      if (e.name === 'QuotaExceededError') {
        console.warn('[Storage] Quota exceeded, pruning backups and retrying...');
        this._pruneAllBackups();
        try {
          localStorage.setItem(this.KEY, JSON.stringify(data));
          return;
        } catch (retryErr) {
          console.error('[Storage] Save failed after cleanup:', retryErr);
          this._notifyUser('保存容量が不足しています。ブラウザの設定を確認してください。');
        }
      } else {
        console.error('[Storage] Failed to save:', e);
      }
    }
  }

  clear() {
    localStorage.removeItem(this.KEY);
  }

  migrate(data) {
    let version = data.schemaVersion || 1;

    if (version > this.CURRENT_VERSION) {
      console.warn('[Storage] Future schema version detected:', version);
      data._readOnly = true;
      return data;
    }

    while (version < this.CURRENT_VERSION) {
      const migrateFn = this.MIGRATIONS[version];
      if (!migrateFn) {
        console.error('[Storage] Missing migration for version', version);
        break;
      }
      data = migrateFn(data);
      version++;
    }

    data.schemaVersion = this.CURRENT_VERSION;
    return data;
  }

  _backupCorrupted() {
    try {
      const raw = localStorage.getItem(this.KEY);
      if (raw) {
        const timestamp = Date.now();
        localStorage.setItem(this.BACKUP_PREFIX + timestamp, raw);
        this._pruneBackups();
      }
    } catch (e) {
      console.error('[Storage] Backup failed:', e);
    }
  }

  _pruneBackups() {
    const keys = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key.startsWith(this.BACKUP_PREFIX)) {
        keys.push(key);
      }
    }
    keys.sort().reverse();
    while (keys.length > this.MAX_BACKUPS) {
      localStorage.removeItem(keys.pop());
    }
  }

  _pruneAllBackups() {
    for (let i = localStorage.length - 1; i >= 0; i--) {
      const key = localStorage.key(i);
      if (key && key.startsWith(this.BACKUP_PREFIX)) {
        localStorage.removeItem(key);
      }
    }
  }

  _notifyUser(message) {
    const banner = document.getElementById('warning-banner');
    if (banner) {
      banner.textContent = message;
      banner.classList.add('visible');
    }
  }

  _deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
}

// ============================================================
// Renderer — FPS-perspective drawing engine using raycasting
// ============================================================
class Renderer {
  constructor(canvas, config = {}) {
    this._canvas = canvas;
    this._ctx = canvas.getContext('2d');
    this._displayWidth = 0;
    this._displayHeight = 0;

    this.EPSILON = 1e-10;

    // Design-spec constants (configurable via config param for testing)
    const defaults = {
      ENEMY_RADIUS: 10,
      FOV_HALF_ANGLE: Math.PI / 6, // 30°
      FOV_RANGE: 250,
      LEAN_OFFSET_X: 20,
      LEAN_ROTATION: (5 * Math.PI) / 180, // 5°
      MAX_SLICE_FACTOR: 4,
      MAX_RAY_DIST_FACTOR: 4,        // ray march / zBuffer sentinel distance (FOV_RANGE × 4)
      MAX_BRIGHTNESS_DIST_FACTOR: 2, // brightness falloff distance (FOV_RANGE × 2, same as pre-optimization)
    };
    Object.assign(this, defaults);
    for (const k of Object.keys(defaults)) {
      if (k in config) this[k] = config[k];
    }

    // Colors matching military-dark theme
    this.COLORS = {
      ceiling: '#1a2a1a',
      floor: '#0d160d',
      wallBase: [90, 106, 122],  // rgb of #5a6a7a
      enemyRGB: [233, 69, 96],   // rgb of #e94560
    };

    // Precomputed per-column tables (populated in resize())
    this._zBuffer = null;
    this._rayDirCos = null;
    this._rayDirSin = null;
    this._fishEyeCorr = null;
    this._wallColorTable = null;
  }

  get width() { return this._displayWidth; }
  get height() { return this._displayHeight; }

  render(state) {
    const ctx = this._ctx;
    const w = this.width;
    const h = this.height;
    if (w === 0 || h === 0) return;

    ctx.clearRect(0, 0, w, h);

    const { obstacles, enemies, character: char, leanState } = this._sanitizeState(state, w, h);

    // Camera position: lean offset with obstacle collision clamp
    const rawVP = this._getViewpoint(char.x, char.y, leanState);
    const vp = this._clampCameraToObstacles(rawVP, char, obstacles);
    const frontAngle = this._getFrontAngle();

    // Apply canvas roll for lean tilt (カメラ横シフト + 画面ロール, not yaw)
    const rollAngle = leanState === 'left' ? -this.LEAN_ROTATION
                    : leanState === 'right' ? this.LEAN_ROTATION : 0;

    ctx.save();
    if (rollAngle !== 0) {
      ctx.translate(w / 2, h / 2);
      ctx.rotate(rollAngle);
      ctx.translate(-w / 2, -h / 2);
    }

    // Draw layers: ceiling/floor → walls → enemy sprites
    const wallScale = h * this.FOV_RANGE;
    const maxDist = this.FOV_RANGE * this.MAX_BRIGHTNESS_DIST_FACTOR;
    this._drawFloorCeiling(ctx, w, h);
    this._castWallRays(ctx, vp, obstacles, w, h, wallScale, maxDist);
    this._drawEnemySprites(ctx, vp, frontAngle, enemies, obstacles, w, h, wallScale, maxDist);

    ctx.restore();
  }

  _sanitizeState(state, w, h) {
    return {
      obstacles: Array.isArray(state?.obstacles) ? state.obstacles : [],
      enemies: Array.isArray(state?.enemies) ? state.enemies : [],
      character: state?.character ?? { x: w / 2, y: h / 2 },
      leanState: state?.leanState ?? 'neutral',
    };
  }

  resize() {
    const container = this._canvas.parentElement;
    if (!container) return;
    const dpr = window.devicePixelRatio || 1;
    this._displayWidth = Math.min(container.clientWidth, 4096);
    this._displayHeight = Math.min(container.clientHeight, 4096);
    this._canvas.width = this._displayWidth * dpr;
    this._canvas.height = this._displayHeight * dpr;
    this._canvas.style.width = this._displayWidth + 'px';
    this._canvas.style.height = this._displayHeight + 'px';
    this._ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    this._precomputeRenderTables();
  }

  destroy() {
    this._ctx = null;
  }

  _precomputeRenderTables() {
    const w = this._displayWidth;
    if (w === 0) return;
    const frontAngle = this._getFrontAngle();
    const fovTotal = this.FOV_HALF_ANGLE * 2;
    const wMinus1 = Math.max(1, w - 1);
    this._zBuffer = new Float32Array(w);
    this._rayDirCos = new Float32Array(w);
    this._rayDirSin = new Float32Array(w);
    this._fishEyeCorr = new Float32Array(w);
    for (let x = 0; x < w; x++) {
      const rayAngle = frontAngle + ((x / wMinus1) - 0.5) * fovTotal;
      this._rayDirCos[x] = Math.cos(rayAngle);
      this._rayDirSin[x] = Math.sin(rayAngle);
      this._fishEyeCorr[x] = Math.cos(rayAngle - frontAngle);
    }
    // Wall color lookup table: 256 brightness levels → pre-built rgb strings
    const [baseR, baseG, baseB] = this.COLORS.wallBase;
    this._wallColorTable = new Array(256);
    for (let i = 0; i < 256; i++) {
      const t = i / 255;
      this._wallColorTable[i] = `rgb(${Math.round(baseR * t)},${Math.round(baseG * t)},${Math.round(baseB * t)})`;
    }
  }

  // --- Viewpoint calculation ---

  _getViewpoint(cx, cy, leanState) {
    let offsetX = 0;
    if (leanState === 'left') offsetX = -this.LEAN_OFFSET_X;
    else if (leanState === 'right') offsetX = this.LEAN_OFFSET_X;
    return { x: cx + offsetX, y: cy };
  }

  _getFrontAngle() {
    // Front direction is -Y (up on canvas) = -PI/2 in atan2.
    // Lean uses canvas roll (not yaw), so the front angle is always fixed.
    return -Math.PI / 2;
  }

  // --- Camera collision ---

  _clampCameraToObstacles(vp, char, obstacles) {
    // Prevent camera from entering obstacles when leaning.
    // If camera lands inside an obstacle, walk back along the lean vector
    // to the obstacle boundary minus a small epsilon.
    const EPS = 0.5;
    for (const obs of obstacles) {
      if (vp.x > obs.x - EPS && vp.x < obs.x + obs.w + EPS &&
          vp.y > obs.y - EPS && vp.y < obs.y + obs.h + EPS) {
        const dx = vp.x - char.x;
        const dy = vp.y - char.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < this.EPSILON) return { x: char.x, y: char.y };
        const ndx = dx / dist;
        const ndy = dy / dist;
        const t = this._rayAABBIntersect(char.x, char.y, ndx, ndy, obs);
        const clampedDist = Math.max(0, t - EPS);
        return { x: char.x + ndx * clampedDist, y: char.y + ndy * clampedDist };
      }
    }
    return vp;
  }

  // --- FPS drawing ---

  _drawFloorCeiling(ctx, w, h) {
    ctx.fillStyle = this.COLORS.ceiling;
    ctx.fillRect(0, 0, w, h / 2);
    ctx.fillStyle = this.COLORS.floor;
    ctx.fillRect(0, h / 2, w, h / 2);
  }

  _castWallRays(ctx, vp, obstacles, w, h, wallScale, maxDist) {
    // Cast one ray per screen column. Fills this._zBuffer with perpendicular distances.
    // Note: ray directions are precomputed in _precomputeRenderTables() at resize time,
    // so frontAngle is not needed here.
    if (!this._zBuffer || !this._rayDirCos) return;
    const zBuf = this._zBuffer;
    const sentinel = this.FOV_RANGE * this.MAX_RAY_DIST_FACTOR;
    zBuf.fill(sentinel);

    let runColor = null;
    let runX = 0;
    let runTop = 0;
    let runH = 0;

    for (let x = 0; x < w; x++) {
      const rdx = this._rayDirCos[x];
      const rdy = this._rayDirSin[x];

      // Find nearest obstacle hit
      let minDist = sentinel;
      for (const obs of obstacles) {
        const t = this._rayAABBIntersect(vp.x, vp.y, rdx, rdy, obs);
        if (t < minDist) minDist = t;
      }

      // Fish-eye correction: project onto the view plane (perpendicular distance)
      const perpDist = Math.max(0.1, minDist * this._fishEyeCorr[x]);
      zBuf[x] = perpDist;

      if (minDist >= sentinel) {
        // Flush current run (no wall here)
        if (runColor !== null) {
          ctx.fillStyle = runColor;
          ctx.fillRect(runX, runTop, x - runX, runH);
          runColor = null;
        }
        continue;
      }

      // Compute wall slice height and vertical bounds
      const sliceH = Math.min(h * this.MAX_SLICE_FACTOR, wallScale / perpDist);
      const wallTop = Math.max(0, Math.round((h - sliceH) / 2));
      const wallBottom = Math.min(h, Math.round((h + sliceH) / 2));
      const sliceActualH = wallBottom - wallTop;

      // Distance shading via precomputed color table
      const brightness = Math.max(0.15, 1 - perpDist / maxDist);
      const color = this._wallColorTable[Math.min(255, Math.round(brightness * 255))];

      // RLE batching: accumulate consecutive columns with identical color and bounds
      if (color === runColor && wallTop === runTop && sliceActualH === runH) {
        // Extend current run
      } else {
        if (runColor !== null) {
          ctx.fillStyle = runColor;
          ctx.fillRect(runX, runTop, x - runX, runH);
        }
        runColor = color;
        runX = x;
        runTop = wallTop;
        runH = sliceActualH;
      }
    }

    // Flush final run
    if (runColor !== null) {
      ctx.fillStyle = runColor;
      ctx.fillRect(runX, runTop, w - runX, runH);
    }
  }

  _drawEnemySprites(ctx, vp, frontAngle, enemies, obstacles, w, h, wallScale, maxDist) {
    // Render enemy billboards sorted far-to-near (painter's algorithm).
    // Each sprite column is clipped against this._zBuffer to avoid rendering
    // enemies visible through walls.
    if (!this._zBuffer) return;
    const zBuf = this._zBuffer;
    const projPlaneDist = (w / 2) / Math.tan(this.FOV_HALF_ANGLE);
    const [eR, eG, eB] = this.COLORS.enemyRGB;

    // Sort far-to-near using a reusable index buffer (avoids per-frame slice + GC)
    const n = enemies.length;
    if (!this._sortIdxBuf || this._sortIdxBuf.length < n) {
      this._sortIdxBuf = new Uint16Array(Math.max(n, 16));
    }
    for (let i = 0; i < n; i++) this._sortIdxBuf[i] = i;
    const sortIdx = this._sortIdxBuf.subarray(0, n);
    sortIdx.sort((a, b) => {
      const dA = (enemies[a].x - vp.x) ** 2 + (enemies[a].y - vp.y) ** 2;
      const dB = (enemies[b].x - vp.x) ** 2 + (enemies[b].y - vp.y) ** 2;
      return dB - dA;
    });

    for (let si = 0; si < n; si++) {
      const enemy = enemies[sortIdx[si]];
      const dx = enemy.x - vp.x;
      const dy = enemy.y - vp.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < this.EPSILON) continue;

      // Skip if outside FOV
      if (!this._isInFOV(vp.x, vp.y, enemy.x, enemy.y, frontAngle)) continue;

      // Skip if fully behind a wall (LOS check along enemy center direction)
      const ndx = dx / dist;
      const ndy = dy / dist;
      let blocked = false;
      for (const obs of obstacles) {
        const t = this._rayAABBIntersect(vp.x, vp.y, ndx, ndy, obs);
        if (t < dist - (enemy.radius || this.ENEMY_RADIUS)) { blocked = true; break; }
      }
      if (blocked) continue;

      // Project enemy center onto screen X
      const angleToEnemy = Math.atan2(dy, dx);
      const angleDiff = Math.atan2(
        Math.sin(angleToEnemy - frontAngle),
        Math.cos(angleToEnemy - frontAngle)
      );
      const screenX = w / 2 + Math.tan(angleDiff) * projPlaneDist;

      // Sprite dimensions based on distance
      const spriteRadius = enemy.radius || this.ENEMY_RADIUS;
      const spriteH = Math.min(h * this.MAX_SLICE_FACTOR, wallScale / dist);
      const spriteW = spriteH * (spriteRadius / this.ENEMY_RADIUS);
      const spriteLeft = Math.round(screenX - spriteW / 2);
      const spriteRight = Math.round(screenX + spriteW / 2);
      const spriteTop = Math.max(0, Math.round((h - spriteH) / 2));
      const spriteBottom = Math.min(h, Math.round((h + spriteH) / 2));
      const spriteDist = dist * Math.cos(angleDiff); // perpendicular depth for zBuffer
      if (!isFinite(spriteDist)) continue; // NaN/Inf guard

      // Distance shading
      const brightness = Math.max(0.3, 1 - dist / maxDist);
      const shadedR = Math.round(eR * brightness);
      const shadedG = Math.round(eG * brightness);
      const shadedB = Math.round(eB * brightness);
      const fillColor = `rgb(${shadedR},${shadedG},${shadedB})`;

      // RLE: batch consecutive visible columns (color/bounds are constant per enemy)
      let runX = -1;
      const xStart = Math.max(0, spriteLeft);
      const xEnd = Math.min(w, spriteRight);
      for (let sx = xStart; sx <= xEnd; sx++) {
        const visible = sx < xEnd && spriteDist < zBuf[sx];
        if (visible) {
          if (runX === -1) runX = sx;
        } else if (runX !== -1) {
          ctx.fillStyle = fillColor;
          ctx.fillRect(runX, spriteTop, sx - runX, spriteBottom - spriteTop);
          runX = -1;
        }
      }
    }
  }

  // --- Raycast / geometry ---

  _isInFOV(vx, vy, tx, ty, frontAngle) {
    const dx = tx - vx;
    const dy = ty - vy;
    const angle = Math.atan2(dy, dx);
    const diff = Math.atan2(Math.sin(angle - frontAngle), Math.cos(angle - frontAngle));
    return Math.abs(diff) <= this.FOV_HALF_ANGLE;
  }

  _rayAABBIntersect(ox, oy, dx, dy, rect) {
    // Slab method: returns distance to first intersection or Infinity
    let tmin = 0;
    let tmax = Infinity;

    // X slab
    if (Math.abs(dx) > this.EPSILON) {
      const invDx = 1 / dx;
      let t1 = (rect.x - ox) * invDx;
      let t2 = (rect.x + rect.w - ox) * invDx;
      if (t1 > t2) { const tmp = t1; t1 = t2; t2 = tmp; }
      tmin = Math.max(tmin, t1);
      tmax = Math.min(tmax, t2);
      if (tmin > tmax) return Infinity;
    } else {
      if (ox < rect.x || ox > rect.x + rect.w) return Infinity;
    }

    // Y slab
    if (Math.abs(dy) > this.EPSILON) {
      const invDy = 1 / dy;
      let t1 = (rect.y - oy) * invDy;
      let t2 = (rect.y + rect.h - oy) * invDy;
      if (t1 > t2) { const tmp = t1; t1 = t2; t2 = tmp; }
      tmin = Math.max(tmin, t1);
      tmax = Math.min(tmax, t2);
      if (tmin > tmax) return Infinity;
    } else {
      if (oy < rect.y || oy > rect.y + rect.h) return Infinity;
    }

    return tmin;
  }
}

// ============================================================
// AudioEngine — AudioContext based sound engine
// ============================================================
class AudioEngine {
  constructor() {
    this._audioCtx = null;
    this._lastError = null;
    this._isListenerRegistered = false;
    this._onVisibilityChange = this._handleVisibilityChange.bind(this);
  }

  /**
   * Initialize AudioContext. Must be called within a user gesture (click/keydown).
   * @returns {Promise<void>}
   */
  async init() {
    if (!this._audioCtx) {
      this._audioCtx = new AudioContext();
      if (!this._isListenerRegistered) {
        document.addEventListener('visibilitychange', this._onVisibilityChange);
        this._isListenerRegistered = true;
      }
    }

    if (this._audioCtx.state === 'suspended') {
      await this._tryResume();
    }
  }

  /**
   * Attempt to resume AudioContext. Shared by init() and resume().
   * @returns {Promise<void>}
   * @private
   */
  async _tryResume() {
    try {
      await this._audioCtx.resume();
      this._lastError = null;
    } catch (e) {
      this._lastError = e;
      throw e;
    }
  }

  /**
   * Schedule a short beat sound at the given AudioContext time.
   * Uses a square wave oscillator for a percussive click sound.
   * @param {number} time - AudioContext.currentTime value to play at
   */
  playBeat(time) {
    if (!this.isReady()) return;

    const ctx = this._audioCtx;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'square';
    osc.frequency.setValueAtTime(880, time);

    gain.gain.setValueAtTime(0.3, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start(time);
    osc.stop(time + 0.05);
  }

  /**
   * Resume AudioContext. Returns a Promise.
   * @returns {Promise<void>}
   */
  async resume() {
    if (!this._audioCtx) return;
    await this._tryResume();
  }

  /**
   * Suspend AudioContext. Returns a Promise.
   * Public API methods (suspend, resume, init) propagate errors via throw
   * so callers can handle them explicitly.
   * @returns {Promise<void>}
   */
  async suspend() {
    if (!this._audioCtx) return;
    try {
      await this._audioCtx.suspend();
    } catch (e) {
      this._lastError = e;
      throw e;
    }
  }

  /**
   * Check if AudioContext is in 'running' state and ready to play.
   * @returns {boolean}
   */
  isReady() {
    return this._audioCtx !== null && this._audioCtx.state === 'running';
  }

  /**
   * Get current AudioContext state.
   * @returns {string} 'suspended' | 'running' | 'closed' | 'uninitialized'
   */
  get state() {
    return this._audioCtx ? this._audioCtx.state : 'uninitialized';
  }

  /**
   * Get the underlying AudioContext's currentTime.
   * @returns {number}
   */
  get currentTime() {
    return this._audioCtx ? this._audioCtx.currentTime : 0;
  }

  /**
   * Get the last error from resume/suspend operations.
   * @returns {Error|null}
   */
  get lastError() {
    return this._lastError;
  }

  /**
   * Handle visibility change for background recovery.
   * When returning from background, check and attempt resume.
   * Unlike public API methods, this internal handler uses catch+warn
   * because it fires automatically without caller context to handle errors.
   */
  _handleVisibilityChange() {
    if (!document.hidden && this._audioCtx && this._audioCtx.state === 'suspended') {
      this._audioCtx.resume().catch(e => {
        this._lastError = e;
        console.warn('[AudioEngine] Failed to resume after visibility change:', e);
      });
    }
  }

  /**
   * Destroy AudioContext and clean up resources.
   * Only call on app teardown, NOT on mode switch.
   */
  destroy() {
    if (this._isListenerRegistered) {
      document.removeEventListener('visibilitychange', this._onVisibilityChange);
      this._isListenerRegistered = false;
    }
    if (this._audioCtx) {
      this._audioCtx.close().catch(e => {
        console.warn('[AudioEngine] Failed to close AudioContext:', e);
      });
      this._audioCtx = null;
    }
  }
}

// ============================================================
// ModeLifecycle — Base class for all practice modes
// ============================================================
class ModeLifecycle {
  constructor(name) {
    this.name = name;
    this._state = 'idle'; // idle | running | paused | result
    this._timers = [];      // setTimeout/setInterval IDs
    this._rafs = [];        // requestAnimationFrame IDs
    this._eventBindings = []; // { target, event, handler, options }
    this._disposables = [];   // cleanup callbacks for non-DOM resources
  }

  get state() { return this._state; }

  enter() {
    this._state = 'idle';
  }

  start() {
    if (this._state !== 'idle' && this._state !== 'result') return;
    this._state = 'running';
  }

  pause() {
    if (this._state !== 'running') return;
    this._state = 'paused';
  }

  resume() {
    if (this._state !== 'paused') return;
    this._state = 'running';
  }

  stop() {
    if (this._state !== 'running' && this._state !== 'paused') return;
    this._state = 'result';
  }

  dispose() {
    // Run custom disposables (non-DOM resource cleanup)
    for (const fn of this._disposables) fn();
    this._disposables.length = 0;

    // Clear all timers
    for (const id of this._timers) {
      clearTimeout(id);
      clearInterval(id);
    }
    this._timers.length = 0;

    // Cancel all animation frames
    for (const id of this._rafs) {
      cancelAnimationFrame(id);
    }
    this._rafs.length = 0;

    // Remove all event listeners
    for (const binding of this._eventBindings) {
      binding.target.removeEventListener(binding.event, binding.handler, binding.options);
    }
    this._eventBindings.length = 0;

    this._state = 'idle';
  }

  // --- Resource tracking helpers ---

  _addTimeout(callback, delay) {
    const id = setTimeout(() => {
      this._timers = this._timers.filter(t => t !== id);
      callback();
    }, delay);
    this._timers.push(id);
    return id;
  }

  _addInterval(callback, delay) {
    const id = setInterval(callback, delay);
    this._timers.push(id);
    return id;
  }

  _addRAF(callback) {
    const id = requestAnimationFrame((ts) => {
      this._rafs = this._rafs.filter(r => r !== id);
      callback(ts);
    });
    this._rafs.push(id);
    return id;
  }

  _addEventListener(target, event, handler, options = undefined) {
    target.addEventListener(event, handler, options);
    this._eventBindings.push({ target, event, handler, options });
  }

  /** Register a cleanup callback invoked on dispose(). Use for non-DOM resources (e.g. EventEmitter listeners). */
  _addDisposable(fn) {
    this._disposables.push(fn);
  }

  /** Remove a tracked timer by ID. Available for subclasses that need mid-lifecycle cleanup. */
  _clearTimer(id) {
    clearTimeout(id);
    clearInterval(id);
    this._timers = this._timers.filter(t => t !== id);
  }

  /** Cancel a tracked RAF by ID. Available for subclasses that need mid-lifecycle cleanup. */
  _cancelRAF(id) {
    cancelAnimationFrame(id);
    this._rafs = this._rafs.filter(r => r !== id);
  }

  // --- Debug info ---

  _getResourceCounts() {
    return {
      timers: this._timers.length,
      rafs: this._rafs.length,
      listeners: this._eventBindings.length
    };
  }
}

// ============================================================
// ModeManager — Mode switching orchestrator
// ============================================================
class ModeManager {
  constructor(inputManager, audioEngine) {
    this._inputManager = inputManager;
    this._audioEngine = audioEngine;
    this._modes = {};       // name -> ModeLifecycle instance
    this._currentMode = null;
    this._currentModeName = null;
  }

  register(name, mode) {
    if (!(mode instanceof ModeLifecycle)) {
      throw new Error('Mode must extend ModeLifecycle');
    }
    this._modes[name] = mode;
  }

  get currentMode() { return this._currentMode; }
  get currentModeName() { return this._currentModeName; }

  async switchTo(name) {
    const nextMode = this._modes[name];
    if (!nextMode) {
      throw new Error('Unknown mode: ' + name);
    }

    if (this._currentMode === nextMode) return;

    // 1. dispose current mode (releases mode-specific resources)
    if (this._currentMode) {
      this._currentMode.dispose();
    }

    // 2. reset input state (clear key presses & lean)
    this._inputManager.resetState();

    // 3. suspend audio (stop sound, don't destroy)
    try {
      await this._audioEngine.suspend();
    } catch (e) {
      console.warn('[ModeManager] AudioEngine suspend failed:', e);
      const panel = document.getElementById('drill-panel');
      if (panel) {
        const warn = document.createElement('div');
        warn.textContent = 'Audio suspend failed – sound may overlap';
        warn.style.cssText = 'color:#e94560;text-align:center;padding:4px;font-size:0.8em';
        panel.prepend(warn);
        setTimeout(() => warn.remove(), 3000);
      }
    }

    // 4. enter new mode
    this._currentMode = nextMode;
    this._currentModeName = name;
    nextMode.enter();
  }

  getMode(name) {
    return this._modes[name] || null;
  }

  getModeNames() {
    return Object.keys(this._modes);
  }
}

// ============================================================
// FreePracticeMode — Free practice with real-time lean display
// ============================================================
class FreePracticeMode extends ModeLifecycle {
  constructor(renderer, inputManager, clock, storage) {
    super('free');
    this._renderer = renderer;
    this._inputManager = inputManager;
    this._clock = clock;
    this._storage = storage;
    this._loopId = null;
    this._lastFrameTime = 0;

    // Movement config
    this.MOVE_SPEED = 150; // pixels per second
    this.CHAR_RADIUS = 15;

    this._scene = {
      character: { x: 0, y: 0 },
      leanState: 'neutral',
      obstacles: [],
      enemies: []
    };

    // Warmup guide state
    this._warmupActive = false;
    this._warmupStep = 0;
    this._warmupSteps = [
      { key: 'KeyW', label: '↑', desc: 'Forward — Move up' },
      { key: 'KeyA', label: '←', desc: 'Left — Move left' },
      { key: 'KeyS', label: '↓', desc: 'Backward — Move down' },
      { key: 'KeyD', label: '→', desc: 'Right — Move right' },
      { key: 'KeyQ', label: null, desc: 'Lean — Peek around cover' },
      { key: 'KeyE', label: null, desc: 'Lean — Peek around cover' },
    ];
  }

  enter() {
    super.enter();
    this._buildScene();
    this._lastFrameTime = this._clock.now();
    this._scene.leanState = this._inputManager.leanState;

    // Update drill panel with mode info
    this._updateDrillPanel();

    // Listen for lean changes
    this._onLeanChange = (data) => {
      this._scene.leanState = data.newState;
    };
    this._inputManager.on('leanchange', this._onLeanChange);
    this._addDisposable(() => {
      this._inputManager.off('leanchange', this._onLeanChange);
      this._onLeanChange = null;
    });

    // Listen for resize
    this._onResize = () => {
      this._renderer.resize();
      this._clampCharacter();
    };
    this._addEventListener(window, 'resize', this._onResize);

    // Check if warmup guide should show
    const appData = this._storage.load();
    if (!appData.freePractice || !appData.freePractice.warmupDone) {
      this._showWarmupGuide();
    }

    // Start render loop
    this._startLoop();
  }

  dispose() {
    if (this._loopId !== null) {
      this._cancelRAF(this._loopId);
      this._loopId = null;
    }
    this._hideWarmupGuide();
    super.dispose();
  }

  _buildScene() {
    const w = this._renderer.width;
    const h = this._renderer.height;
    const cx = w / 2;
    const cy = h * 0.65;

    this._scene.character.x = cx;
    this._scene.character.y = cy;

    // Arena layout: walls and corners for peek practice
    this._scene.obstacles = [
      // Top horizontal wall with gap in center
      { x: cx - 140, y: cy - 160, w: 120, h: 14 },
      { x: cx + 20, y: cy - 160, w: 120, h: 14 },
      // Left vertical wall (creates left corner)
      { x: cx - 140, y: cy - 160, w: 14, h: 90 },
      // Right vertical wall (creates right corner)
      { x: cx + 126, y: cy - 160, w: 14, h: 70 },
      // Center cover box (partial cover)
      { x: cx - 25, y: cy - 90, w: 50, h: 14 },
    ];

    // Enemies behind cover at various angles
    this._scene.enemies = [
      { x: cx, y: cy - 230, radius: 10 },       // center, behind gap
      { x: cx - 100, y: cy - 220, radius: 10 },  // left, behind left wall
      { x: cx + 90, y: cy - 210, radius: 10 },   // right, behind right wall
    ];
  }

  _startLoop() {
    this._lastFrameTime = this._clock.now();
    const loop = () => {
      const now = this._clock.now();
      const dt = Math.min((now - this._lastFrameTime) / 1000, 0.1); // cap at 100ms
      this._lastFrameTime = now;

      // Update movement from WASD keys
      if (!this._warmupActive) {
        this._updateMovement(dt);
      }

      // Sync lean state
      this._scene.leanState = this._inputManager.leanState;

      // Render every frame (movement is continuous)
      this._renderer.render(this._scene);

      this._loopId = this._addRAF(loop);
    };
    this._loopId = this._addRAF(loop);
  }

  _updateMovement(dt) {
    const keys = this._inputManager.pressedKeys;
    let dx = 0;
    let dy = 0;

    if (keys.has('KeyW')) dy -= 1;
    if (keys.has('KeyS')) dy += 1;
    if (keys.has('KeyA')) dx -= 1;
    if (keys.has('KeyD')) dx += 1;

    if (dx === 0 && dy === 0) return;

    // Normalize diagonal movement
    const len = Math.sqrt(dx * dx + dy * dy);
    dx = (dx / len) * this.MOVE_SPEED * dt;
    dy = (dy / len) * this.MOVE_SPEED * dt;

    const char = this._scene.character;
    const newX = char.x + dx;
    const newY = char.y + dy;

    // Try full movement, then slide along each axis independently
    if (!this._collidesWithObstacle(newX, newY)) {
      char.x = newX;
      char.y = newY;
    } else {
      if (!this._collidesWithObstacle(newX, char.y)) {
        char.x = newX;
      }
      if (!this._collidesWithObstacle(char.x, newY)) {
        char.y = newY;
      }
    }

    this._clampCharacter();
  }

  _collidesWithObstacle(cx, cy) {
    const r = this.CHAR_RADIUS;
    for (const obs of this._scene.obstacles) {
      // Circle vs AABB collision
      const nearX = Math.max(obs.x, Math.min(cx, obs.x + obs.w));
      const nearY = Math.max(obs.y, Math.min(cy, obs.y + obs.h));
      const distX = cx - nearX;
      const distY = cy - nearY;
      if (distX * distX + distY * distY < r * r) return true;
    }
    return false;
  }

  _clampCharacter() {
    const r = this.CHAR_RADIUS;
    const w = this._renderer.width;
    const h = this._renderer.height;
    const char = this._scene.character;
    char.x = Math.max(r, Math.min(w - r, char.x));
    char.y = Math.max(r, Math.min(h - r, char.y));
  }

  _updateDrillPanel() {
    const panel = document.getElementById('drill-panel');
    if (!panel) return;
    panel.textContent = '';
    const info = document.createElement('div');
    info.className = 'free-practice-info';

    const title = document.createElement('div');
    title.className = 'fp-title';
    title.textContent = 'FREE PRACTICE';
    info.appendChild(title);

    const controls = document.createElement('div');
    controls.className = 'fp-controls';
    controls.textContent = 'Move: WASD  |  Lean: Q / E';
    info.appendChild(controls);

    const legend = document.createElement('div');
    legend.className = 'fp-legend';
    legend.appendChild(document.createTextNode('Peek around cover to spot enemies.'));
    legend.appendChild(document.createElement('br'));
    const greenSpan = document.createElement('span');
    greenSpan.className = 'fp-legend-visible';
    greenSpan.textContent = 'Green ray';
    legend.appendChild(greenSpan);
    legend.appendChild(document.createTextNode(' = visible \u00A0 '));
    const redSpan = document.createElement('span');
    redSpan.className = 'fp-legend-blocked';
    redSpan.textContent = 'Red ray';
    legend.appendChild(redSpan);
    legend.appendChild(document.createTextNode(' = blocked'));
    info.appendChild(legend);

    panel.appendChild(info);
  }

  // --- Warmup Guide ---

  _showWarmupGuide() {
    this._warmupActive = true;
    this._warmupStep = 0;
    this._previousFocus = document.activeElement;
    const guide = document.getElementById('warmup-guide');
    if (!guide) return;
    guide.setAttribute('role', 'dialog');
    guide.setAttribute('aria-label', 'Warmup Guide');
    guide.setAttribute('aria-modal', 'true');
    guide.classList.add('active');

    const progressEl = document.getElementById('warmup-progress');
    if (progressEl) progressEl.setAttribute('aria-live', 'polite');

    this._renderWarmupStep();

    // Focus the skip button so keyboard users can interact
    const skipBtn = document.getElementById('warmup-skip');
    if (skipBtn) skipBtn.focus();

    // Key handler for warmup
    this._onWarmupKey = (data) => {
      if (!this._warmupActive) return;
      const step = this._warmupSteps[this._warmupStep];
      if (data.code === step.key) {
        // Highlight key briefly
        const keyEl = document.getElementById('warmup-key');
        if (keyEl) keyEl.classList.add('pressed');
        this._addTimeout(() => {
          if (keyEl) keyEl.classList.remove('pressed');
          this._warmupStep++;
          if (this._warmupStep >= this._warmupSteps.length) {
            this._completeWarmup();
          } else {
            this._renderWarmupStep();
          }
        }, 200);
      }
    };
    this._inputManager.on('keydown', this._onWarmupKey);
    this._addDisposable(() => {
      this._inputManager.off('keydown', this._onWarmupKey);
      this._onWarmupKey = null;
    });

    // Skip button
    if (skipBtn) {
      this._onSkip = () => this._completeWarmup();
      this._addEventListener(skipBtn, 'click', this._onSkip);
    }
  }

  _renderWarmupStep() {
    const step = this._warmupSteps[this._warmupStep];
    const keyEl = document.getElementById('warmup-key');
    const descEl = document.getElementById('warmup-desc');
    const progressEl = document.getElementById('warmup-progress');
    const label = step.label !== null ? step.label : this._inputManager.getKeySymbol(step.key);
    if (keyEl) { keyEl.textContent = label; keyEl.classList.remove('pressed'); }
    if (descEl) descEl.textContent = step.desc;
    if (progressEl) {
      progressEl.textContent = '';
      this._warmupSteps.forEach((_, i) => {
        const dot = document.createElement('div');
        dot.className = 'warmup-dot' +
          (i < this._warmupStep ? ' done' : i === this._warmupStep ? ' current' : '');
        progressEl.appendChild(dot);
      });
    }
  }

  _completeWarmup() {
    this._warmupActive = false;
    this._hideWarmupGuide();
    // Save warmup completion
    const appData = this._storage.load();
    if (!appData.freePractice) appData.freePractice = {};
    appData.freePractice.warmupDone = true;
    this._storage.save(appData);
  }

  _hideWarmupGuide() {
    const guide = document.getElementById('warmup-guide');
    if (guide) {
      guide.classList.remove('active');
      guide.removeAttribute('aria-modal');
    }
    if (this._previousFocus && typeof this._previousFocus.focus === 'function') {
      this._previousFocus.focus();
      this._previousFocus = null;
    }
  }
}

// ============================================================
// ReactionDrillMode — Key reaction drill with progressive levels
// ============================================================
class ReactionDrillMode extends ModeLifecycle {
  constructor(inputManager, clock, storage, appData) {
    super('reaction');
    this._input = inputManager;
    this._clock = clock;
    this._storage = storage;
    this._appData = appData;
    this._drillPanel = null;

    // Level definitions
    this._levelDefs = {
      1: { name: 'Lv1', label: 'Single Key', keys: [
        ['KeyQ'], ['KeyE'], ['KeyW'], ['KeyA'], ['KeyS'], ['KeyD']
      ]},
      2: { name: 'Lv2', label: '2-Key Combo', keys: [
        ['KeyD', 'KeyE'], ['KeyA', 'KeyQ'], ['KeyW', 'KeyE'],
        ['KeyS', 'KeyQ'], ['KeyW', 'KeyD'], ['KeyA', 'KeyE']
      ]},
      3: { name: 'Lv3', label: '3-Key Combo', keys: [
        ['KeyW', 'KeyD', 'KeyE'], ['KeyW', 'KeyA', 'KeyQ'],
        ['KeyS', 'KeyD', 'KeyE'], ['KeyS', 'KeyA', 'KeyQ']
      ]}
    };

    // Key display via InputManager.getKeySymbol()

    // Drill state
    this._currentLevel = 1;
    this._questions = [];
    this._questionIndex = 0;
    this._promptTime = 0;
    this._reactionTimes = [];
    this._waitingForInput = false;
    this._showingFeedback = false;

    // KRO tracking
    this._kroAttempts = {};

    // Simultaneous key tracking
    this._pendingKeys = null;
    this._firstKeyTime = 0;
    this._comboTimeout = null;
  }

  enter() {
    super.enter();
    this._drillPanel = document.getElementById('drill-panel');
    this._loadProgress();
    this._showIdleUI();
  }

  start() {
    if (this._state !== 'idle' && this._state !== 'result') return;
    super.start();
    this._generateQuestions();
    this._questionIndex = 0;
    this._reactionTimes = [];
    this._showCountdown();
  }

  pause() {
    if (this._state !== 'running') return;
    super.pause();
    this._waitingForInput = false;
    this._showPauseUI();
  }

  resume() {
    if (this._state !== 'paused') return;
    super.resume();
    this._showNextPrompt();
  }

  stop() {
    if (this._state !== 'running' && this._state !== 'paused') return;
    super.stop();
    this._waitingForInput = false;
    this._showResultUI();
  }

  dispose() {
    this._waitingForInput = false;
    this._showingFeedback = false;
    this._pendingKeys = null;
    this._comboTimeout = null;
    super.dispose();
  }

  // --- Progress Persistence ---

  _loadProgress() {
    const data = this._appData.reactionDrill || { levels: {}, best: {} };
    // Determine unlocked levels
    this._unlockedLevels = new Set([1]);
    if (data.levels[1] && data.levels[1].avg && data.levels[1].avg <= ReactionDrillMode.UNLOCK_THRESHOLD_MS) {
      this._unlockedLevels.add(2);
    }
    if (data.levels[2] && data.levels[2].avg && data.levels[2].avg <= ReactionDrillMode.UNLOCK_THRESHOLD_MS) {
      this._unlockedLevels.add(3);
    }
    // Restore KRO data
    if (this._appData.kro && this._appData.kro.drillFailCounts) {
      for (const [combo, count] of Object.entries(this._appData.kro.drillFailCounts)) {
        this._kroAttempts[combo] = this._kroAttempts[combo] || { total: 0, failed: 0 };
        this._kroAttempts[combo].failed = count;
      }
    }
  }

  _saveProgress() {
    if (this._reactionTimes.length === 0) return;
    const avg = Math.round(this._reactionTimes.reduce((a, b) => a + b, 0) / this._reactionTimes.length);
    const best = Math.round(Math.min(...this._reactionTimes));
    const lvl = this._currentLevel;

    const data = this._appData.reactionDrill || { levels: {}, best: {} };
    if (!data.levels[lvl] || avg < data.levels[lvl].avg) {
      data.levels[lvl] = { avg, best, timestamp: Date.now() };
    }
    if (!data.best[lvl] || best < data.best[lvl]) {
      data.best[lvl] = best;
    }
    this._appData.reactionDrill = data;

    // Save KRO fail counts
    const failCounts = {};
    for (const [combo, stats] of Object.entries(this._kroAttempts)) {
      if (stats.failed > 0) failCounts[combo] = stats.failed;
    }
    this._appData.kro = this._appData.kro || { diagnosis: null, failedCombos: {}, drillFailCounts: {} };
    this._appData.kro.drillFailCounts = failCounts;

    this._storage.save(this._appData);

    // Update unlocked levels
    if (lvl === 1 && avg <= ReactionDrillMode.UNLOCK_THRESHOLD_MS) this._unlockedLevels.add(2);
    if (lvl === 2 && avg <= ReactionDrillMode.UNLOCK_THRESHOLD_MS) this._unlockedLevels.add(3);
  }

  // --- Question Generation ---

  _generateQuestions() {
    const combos = this._levelDefs[this._currentLevel].keys;
    this._questions = [];
    for (let i = 0; i < ReactionDrillMode.QUESTIONS_PER_SET; i++) {
      const idx = Math.floor(Math.random() * combos.length);
      this._questions.push([...combos[idx]]);
    }
  }

  // --- Helpers ---

  _createDrillHeader(rightText) {
    const header = document.createElement('div');
    header.className = 'drill-header';
    const lvlSpan = document.createElement('span');
    lvlSpan.textContent = this._levelDefs[this._currentLevel].name;
    header.appendChild(lvlSpan);
    if (rightText) {
      const rightSpan = document.createElement('span');
      rightSpan.textContent = rightText;
      header.appendChild(rightSpan);
    }
    return header;
  }

  _getComboKey(keys) {
    return [...keys].sort().join('+');
  }

  // --- UI Rendering ---

  _showIdleUI() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.add('drill-panel-idle');

    // Level tabs
    const header = document.createElement('div');
    header.className = 'drill-header';

    const tabs = document.createElement('div');
    tabs.className = 'drill-level-tabs';
    for (let lv = 1; lv <= 3; lv++) {
      const tab = document.createElement('button');
      tab.className = 'drill-level-tab';
      tab.textContent = this._levelDefs[lv].name;
      const isUnlocked = this._unlockedLevels.has(lv);
      if (!isUnlocked) {
        tab.classList.add('locked');
        tab.disabled = true;
      }
      if (lv === this._currentLevel) tab.classList.add('active');
      if (isUnlocked) {
        tab.addEventListener('click', () => {
          this._currentLevel = lv;
          this._showIdleUI();
        });
      }
      tabs.appendChild(tab);
    }
    header.appendChild(tabs);

    const levelLabel = document.createElement('span');
    levelLabel.textContent = this._levelDefs[this._currentLevel].label;
    header.appendChild(levelLabel);
    panel.appendChild(header);

    // Best score display
    const data = this._appData.reactionDrill || { levels: {}, best: {} };
    const lvlData = data.levels[this._currentLevel];
    if (lvlData) {
      const bestDiv = document.createElement('div');
      bestDiv.className = 'drill-progress';
      bestDiv.textContent = 'Best Avg: ' + lvlData.avg + 'ms | Best: ' + (data.best[this._currentLevel] || lvlData.best) + 'ms';
      panel.appendChild(bestDiv);
    }

    // Prompt area
    const prompt = document.createElement('div');
    prompt.className = 'drill-prompt';
    prompt.setAttribute('aria-live', 'polite');

    const instruction = document.createElement('div');
    instruction.className = 'drill-prompt-instruction';
    if (this._currentLevel === 1) {
      instruction.textContent = 'Press the shown key as fast as you can';
    } else {
      instruction.textContent = 'Press all keys simultaneously (within 80ms)';
    }
    prompt.appendChild(instruction);

    const startBtn = document.createElement('button');
    startBtn.className = 'drill-btn';
    startBtn.textContent = 'Start Drill';
    startBtn.addEventListener('click', () => this.start());
    prompt.appendChild(startBtn);
    panel.appendChild(prompt);
  }

  _showCountdown() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    const countdown = document.createElement('div');
    countdown.className = 'drill-countdown';

    // Bind keydown handler once for the entire drill session
    this._onKeyDown = (data) => this._handleDrillKey(data);
    this._input.on('keydown', this._onKeyDown);
    this._addDisposable(() => {
      this._input.off('keydown', this._onKeyDown);
      this._onKeyDown = null;
    });

    let count = 3;
    countdown.textContent = count;
    panel.appendChild(countdown);

    const tick = () => {
      count--;
      if (count > 0) {
        countdown.textContent = count;
        this._addTimeout(tick, ReactionDrillMode.COUNTDOWN_INTERVAL_MS);
      } else {
        this._showNextPrompt();
      }
    };
    this._addTimeout(tick, ReactionDrillMode.COUNTDOWN_INTERVAL_MS);
  }

  _showNextPrompt() {
    if (this._questionIndex >= this._questions.length) {
      this.stop();
      return;
    }

    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    const currentKeys = this._questions[this._questionIndex];

    // Header with progress
    panel.appendChild(this._createDrillHeader((this._questionIndex + 1) + ' / ' + this._questions.length));

    // Key prompt
    const prompt = document.createElement('div');
    prompt.className = 'drill-prompt';
    prompt.setAttribute('aria-live', 'polite');

    const keysDiv = document.createElement('div');
    keysDiv.className = 'drill-prompt-keys';
    for (let i = 0; i < currentKeys.length; i++) {
      if (i > 0) {
        const plus = document.createElement('span');
        plus.className = 'drill-prompt-plus';
        plus.textContent = '+';
        keysDiv.appendChild(plus);
      }
      const keyEl = document.createElement('div');
      keyEl.className = 'drill-prompt-key';
      keyEl.textContent = this._input.getKeySymbol(currentKeys[i]);
      keysDiv.appendChild(keyEl);
    }
    prompt.appendChild(keysDiv);

    const instruction = document.createElement('div');
    instruction.className = 'drill-prompt-instruction';
    instruction.textContent = currentKeys.length === 1 ? 'Press now!' : 'Press all at once!';
    prompt.appendChild(instruction);

    panel.appendChild(prompt);

    // Activate input detection with random delay
    this._waitingForInput = false;
    this._pendingKeys = null;
    this._firstKeyTime = 0;

    const delay = ReactionDrillMode.PROMPT_DELAY_MIN_MS + Math.random() * ReactionDrillMode.PROMPT_DELAY_RANGE_MS;
    this._addTimeout(() => {
      if (this._state !== 'running') return;
      this._promptTime = this._clock.now();
      this._waitingForInput = true;

      if (currentKeys.length > 1) {
        this._pendingKeys = new Set(currentKeys);
        this._firstKeyTime = 0;
      }

      // Visual cue: highlight prompt keys
      const keyEls = panel.querySelectorAll('.drill-prompt-key');
      keyEls.forEach(el => el.classList.add('active'));
      if (instruction) instruction.textContent = currentKeys.length === 1 ? 'NOW!' : 'NOW! Press all!';
    }, delay);
  }

  _handleDrillKey(data) {
    if (!this._waitingForInput || this._state !== 'running') return;

    const currentKeys = this._questions[this._questionIndex];
    const pressedCode = data.code;

    // Single key level
    if (currentKeys.length === 1) {
      if (pressedCode === currentKeys[0]) {
        const reaction = this._clock.now() - this._promptTime;
        this._recordReaction(reaction, currentKeys);
      }
      return;
    }

    // Multi-key level: check if pressed key is one of the expected keys
    if (!this._pendingKeys || !this._pendingKeys.has(pressedCode)) return;

    const now = this._clock.now();
    if (this._firstKeyTime === 0) {
      this._firstKeyTime = now;
    }

    this._pendingKeys.delete(pressedCode);

    // Check if all keys pressed
    if (this._pendingKeys.size === 0) {
      // Verify simultaneity (within 80ms window)
      const elapsed = now - this._firstKeyTime;
      if (elapsed <= this._input.SIMULTANEOUS_WINDOW) {
        // Last key time - prompt time = reaction
        const reaction = now - this._promptTime;
        this._recordReaction(reaction, currentKeys);
      } else {
        // Not simultaneous — treat as miss, track for KRO
        this._recordMiss(currentKeys, false);
      }
      return;
    }

    // Check timeout: if first key was pressed but 80ms passed, it's a fail
    this._comboTimeout = this._addTimeout(() => {
      if (this._pendingKeys && this._pendingKeys.size > 0 && this._waitingForInput) {
        this._recordMiss(currentKeys, true);
      }
    }, this._input.SIMULTANEOUS_WINDOW + 10);
  }

  _recordReaction(reactionMs, keys) {
    this._waitingForInput = false;
    this._showingFeedback = true;
    if (this._comboTimeout != null) {
      this._clearTimer(this._comboTimeout);
      this._comboTimeout = null;
    }
    this._reactionTimes.push(reactionMs);

    // Track successful attempt for KRO
    if (keys.length > 1) {
      const comboKey = this._getComboKey(keys);
      if (!this._kroAttempts[comboKey]) this._kroAttempts[comboKey] = { total: 0, failed: 0 };
      this._kroAttempts[comboKey].total++;
    }

    this._showFeedback(reactionMs, true);
  }

  _recordMiss(keys, possibleKro) {
    this._waitingForInput = false;
    this._showingFeedback = true;
    this._pendingKeys = null;

    this._reactionTimes.push(ReactionDrillMode.MISS_PENALTY_MS);

    // Track for KRO
    if (keys.length > 1) {
      const comboKey = this._getComboKey(keys);
      if (!this._kroAttempts[comboKey]) this._kroAttempts[comboKey] = { total: 0, failed: 0 };
      this._kroAttempts[comboKey].total++;
      if (possibleKro) this._kroAttempts[comboKey].failed++;
    }

    this._showFeedback(null, false);
  }

  _showFeedback(reactionMs, success) {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    panel.appendChild(this._createDrillHeader((this._questionIndex + 1) + ' / ' + this._questions.length));

    const prompt = document.createElement('div');
    prompt.className = 'drill-prompt';

    if (success) {
      const timeDiv = document.createElement('div');
      timeDiv.className = 'drill-reaction-time';
      if (reactionMs > 500) timeDiv.classList.add('slow');
      timeDiv.textContent = Math.round(reactionMs) + 'ms';
      prompt.appendChild(timeDiv);
    } else {
      const missDiv = document.createElement('div');
      missDiv.className = 'drill-reaction-time slow';
      missDiv.textContent = 'MISS';
      prompt.appendChild(missDiv);

      // Check KRO warning
      const currentKeys = this._questions[this._questionIndex];
      if (currentKeys.length > 1) {
        const comboKey = this._getComboKey(currentKeys);
        const stats = this._kroAttempts[comboKey];
        if (stats && stats.total >= ReactionDrillMode.KRO_MIN_ATTEMPTS && (stats.failed / stats.total) >= ReactionDrillMode.KRO_FAIL_THRESHOLD) {
          const warning = document.createElement('div');
          warning.className = 'drill-kro-warning';
          warning.textContent = 'KRO Warning: This combination may not be detectable due to keyboard limitations';
          prompt.appendChild(warning);
        }
      }
    }

    panel.appendChild(prompt);

    // Advance to next question
    this._questionIndex++;
    this._addTimeout(() => {
      this._showingFeedback = false;
      if (this._state === 'running') {
        this._showNextPrompt();
      }
    }, ReactionDrillMode.FEEDBACK_DURATION_MS);
  }

  _showPauseUI() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    const prompt = document.createElement('div');
    prompt.className = 'drill-prompt';

    const label = document.createElement('div');
    label.className = 'drill-prompt-instruction';
    label.textContent = 'Paused — Press ESC to resume';
    prompt.appendChild(label);

    panel.appendChild(prompt);
  }

  _showResultUI() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    const result = document.createElement('div');
    result.className = 'drill-result';

    const title = document.createElement('div');
    title.className = 'drill-result-title';
    title.textContent = 'Drill Complete';
    result.appendChild(title);

    // Stats
    const validTimes = this._reactionTimes.filter(t => t < ReactionDrillMode.MISS_PENALTY_MS);
    const missCount = this._reactionTimes.length - validTimes.length;
    const avg = validTimes.length > 0 ? Math.round(validTimes.reduce((a, b) => a + b, 0) / validTimes.length) : 0;
    const best = validTimes.length > 0 ? Math.round(Math.min(...validTimes)) : 0;

    const stats = document.createElement('div');
    stats.className = 'drill-result-stats';

    const avgStat = this._createStat(avg + 'ms', 'Avg Time');
    const bestStat = this._createStat(best + 'ms', 'Best');
    const missStat = this._createStat(missCount + '', 'Misses');
    stats.appendChild(avgStat);
    stats.appendChild(bestStat);
    stats.appendChild(missStat);
    result.appendChild(stats);

    // Level up notification
    const prevUnlocked = new Set(this._unlockedLevels);
    this._saveProgress();
    if (this._currentLevel < 3 && !prevUnlocked.has(this._currentLevel + 1) && this._unlockedLevels.has(this._currentLevel + 1)) {
      const levelUp = document.createElement('div');
      levelUp.className = 'drill-level-up';
      levelUp.textContent = 'Level ' + (this._currentLevel + 1) + ' Unlocked!';
      result.appendChild(levelUp);
    }

    // KRO warnings summary
    const kroWarnings = this._getKroWarnings();
    if (kroWarnings.length > 0) {
      const warning = document.createElement('div');
      warning.className = 'drill-kro-warning';
      warning.textContent = 'KRO Warning: ' + kroWarnings.join(', ') + ' — these combinations may not be detectable due to keyboard limitations';
      result.appendChild(warning);
    }

    // Buttons
    const btnGroup = document.createElement('div');
    btnGroup.className = 'drill-btn-group';

    const retryBtn = document.createElement('button');
    retryBtn.className = 'drill-btn';
    retryBtn.textContent = 'Retry';
    retryBtn.addEventListener('click', () => this.start());
    btnGroup.appendChild(retryBtn);

    if (this._currentLevel < 3 && this._unlockedLevels.has(this._currentLevel + 1)) {
      const nextBtn = document.createElement('button');
      nextBtn.className = 'drill-btn';
      nextBtn.textContent = 'Next Level';
      nextBtn.addEventListener('click', () => {
        this._currentLevel++;
        this.start();
      });
      btnGroup.appendChild(nextBtn);
    }

    result.appendChild(btnGroup);
    panel.appendChild(result);
  }

  _createStat(value, label) {
    const div = document.createElement('div');
    div.className = 'drill-result-stat';
    const valEl = document.createElement('div');
    valEl.className = 'drill-result-stat-value';
    valEl.textContent = value;
    const lblEl = document.createElement('div');
    lblEl.className = 'drill-result-stat-label';
    lblEl.textContent = label;
    div.appendChild(valEl);
    div.appendChild(lblEl);
    return div;
  }

  _getKroWarnings() {
    const warnings = [];
    for (const [combo, stats] of Object.entries(this._kroAttempts)) {
      if (stats.total >= ReactionDrillMode.KRO_MIN_ATTEMPTS && (stats.failed / stats.total) >= ReactionDrillMode.KRO_FAIL_THRESHOLD) {
        const keys = combo.split('+').map(k => this._input.getKeySymbol(k));
        warnings.push(keys.join('+'));
      }
    }
    return warnings;
  }
}

ReactionDrillMode.MISS_PENALTY_MS = 2000;
ReactionDrillMode.COUNTDOWN_INTERVAL_MS = 600;
ReactionDrillMode.FEEDBACK_DURATION_MS = 800;
ReactionDrillMode.PROMPT_DELAY_MIN_MS = 300;
ReactionDrillMode.PROMPT_DELAY_RANGE_MS = 700;
ReactionDrillMode.UNLOCK_THRESHOLD_MS = 500;
ReactionDrillMode.QUESTIONS_PER_SET = 10;
ReactionDrillMode.KRO_MIN_ATTEMPTS = 5;
ReactionDrillMode.KRO_FAIL_THRESHOLD = 0.6;

// ============================================================
// Combo Drill Data — Data-driven technique definitions
// ============================================================
const COMBOS = [
  {
    id: 'jiggle_right',
    name: 'ジグルピーク右',
    steps: [
      { action: 'press', keys: ['KeyE'], maxDuration: 300, simultaneousWindow: 0 },
      { action: 'release', keys: ['KeyE'], maxDuration: 200, simultaneousWindow: 0 }
    ],
    repeatCount: 3,
    description: '右リーンで素早く出入り。EFTの基本テクニック'
  },
  {
    id: 'strafe_peek_right',
    name: 'ストレイフピーク右',
    steps: [
      { action: 'press', keys: ['KeyD', 'KeyE'], maxDuration: 500, simultaneousWindow: 80 },
      { action: 'release', keys: ['KeyD', 'KeyE'], maxDuration: 300, simultaneousWindow: 80 },
      { action: 'press', keys: ['KeyA', 'KeyQ'], maxDuration: 500, simultaneousWindow: 80 },
      { action: 'release', keys: ['KeyA', 'KeyQ'], maxDuration: 300, simultaneousWindow: 80 }
    ],
    repeatCount: 2,
    description: '右移動+右リーンで飛び出し、左で引く'
  },
  {
    id: 'forward_peek_right',
    name: '前進ピーク右',
    steps: [
      { action: 'press', keys: ['KeyW', 'KeyD', 'KeyE'], maxDuration: 500, simultaneousWindow: 80 },
      { action: 'release', keys: ['KeyW', 'KeyD', 'KeyE'], maxDuration: 300, simultaneousWindow: 80 }
    ],
    repeatCount: 2,
    description: '前進+右移動+右リーンで素早くピーク'
  },
  {
    id: 'alternating_peek',
    name: '交互ピーク',
    steps: [
      { action: 'press', keys: ['KeyE'], maxDuration: 300, simultaneousWindow: 0 },
      { action: 'release', keys: ['KeyE'], maxDuration: 200, simultaneousWindow: 0 },
      { action: 'press', keys: ['KeyQ'], maxDuration: 300, simultaneousWindow: 0 },
      { action: 'release', keys: ['KeyQ'], maxDuration: 200, simultaneousWindow: 0 }
    ],
    repeatCount: 3,
    description: '右→左と交互にリーン。素早い切り替えが重要'
  }
];

// ============================================================
// ComboDrillMode — Combo drill with data-driven techniques
// ============================================================
class ComboDrillMode extends ModeLifecycle {
  constructor(inputManager, clock, storage, appData) {
    super('combo');
    this._input = inputManager;
    this._clock = clock;
    this._storage = storage;
    this._appData = appData;
    this._drillPanel = null;
    // Key display via InputManager.getKeySymbol()

    // Drill state
    this._selectedCombo = null;
    this._currentStepIndex = 0;
    this._currentRepeat = 0;
    this._stepStartTime = 0;
    this._pendingKeys = null;
    this._firstKeyTime = 0;
    this._stepResults = []; // per-repeat: true/false
    this._waitingForInput = false;

    // Track per-repeat failure
    this._currentRepeatHadFailure = false;
    this._newUnlock = null;

    // Unlocked techniques
    this._unlockedCombos = new Set();

    // Demo animation state
    this._demoAnimating = false;
  }

  _resolveKey(key) {
    if (!this._input.useEftStandard) {
      if (key === 'KeyQ') return 'KeyE';
      if (key === 'KeyE') return 'KeyQ';
    }
    return key;
  }

  _resolveStepKeys(keys) {
    return keys.map(k => this._resolveKey(k));
  }

  enter() {
    super.enter();
    this._drillPanel = document.getElementById('drill-panel');
    this._loadProgress();
    this._showIdleUI();
  }

  start() {
    if (this._state !== 'idle' && this._state !== 'result') return;
    if (!this._selectedCombo) return;
    super.start();
    this._currentStepIndex = 0;
    this._currentRepeat = 0;
    this._stepResults = [];
    this._waitingForInput = false;
    this._currentRepeatHadFailure = false;
    this._newUnlock = null;
    this._showCountdown();
  }

  pause() {
    if (this._state !== 'running') return;
    super.pause();
    this._waitingForInput = false;
    this._showPauseUI();
  }

  resume() {
    if (this._state !== 'paused') return;
    super.resume();
    this._prepareStep();
  }

  stop() {
    if (this._state !== 'running' && this._state !== 'paused') return;
    super.stop();
    this._waitingForInput = false;
    this._saveProgress();
    this._showResultUI();
  }

  dispose() {
    this._waitingForInput = false;
    this._pendingKeys = null;
    this._demoAnimating = false;
    super.dispose();
  }

  // --- Progress Persistence ---

  _loadProgress() {
    const data = this._appData.comboDrill || { techniques: {}, unlocked: ['jiggle_right'] };
    this._unlockedCombos = new Set(data.unlocked || ['jiggle_right']);
    this._unlockedCombos.add('jiggle_right');
    this._checkUnlocks(data);
  }

  _checkUnlocks(data) {
    for (let i = 0; i < ComboDrillMode.UNLOCK_ORDER.length - 1; i++) {
      const current = ComboDrillMode.UNLOCK_ORDER[i];
      const next = ComboDrillMode.UNLOCK_ORDER[i + 1];
      if (data.techniques[current] && data.techniques[current].successRate >= ComboDrillMode.UNLOCK_THRESHOLD) {
        this._unlockedCombos.add(next);
      }
    }
  }

  _saveProgress() {
    const combo = this._selectedCombo;
    if (!combo || this._stepResults.length === 0) return;

    const successCount = this._stepResults.filter(r => r).length;
    const successRate = successCount / this._stepResults.length;

    const data = this._appData.comboDrill || { techniques: {}, unlocked: [] };
    data.techniques[combo.id] = data.techniques[combo.id] || { attempts: 0, successRate: 0 };
    const tech = data.techniques[combo.id];
    // Rolling average with previous
    const prevAttempts = tech.attempts || 0;
    const prevRate = tech.successRate || 0;
    tech.successRate = prevAttempts === 0
      ? successRate
      : (prevRate * prevAttempts + successRate) / (prevAttempts + 1);
    tech.attempts = prevAttempts + 1;
    tech.lastPlayed = Date.now();

    // Update unlocked set
    const prevUnlocked = new Set(this._unlockedCombos);
    this._checkUnlocks(data);
    data.unlocked = [...this._unlockedCombos];
    this._appData.comboDrill = data;
    this._storage.save(this._appData);

    // Check for new unlocks
    this._newUnlock = null;
    for (const id of this._unlockedCombos) {
      if (!prevUnlocked.has(id)) {
        this._newUnlock = COMBOS.find(c => c.id === id);
        break;
      }
    }
  }

  // --- Countdown ---

  _showCountdown() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    const countdown = document.createElement('div');
    countdown.className = 'drill-countdown';

    // Remove any existing key handlers before binding new ones (prevents leak on Retry)
    if (this._onKeyDown) {
      this._input.off('keydown', this._onKeyDown);
      this._input.off('keyup', this._onKeyUp);
    }
    this._onKeyDown = (data) => this._handleStepKey(data, 'press');
    this._onKeyUp = (data) => this._handleStepKey(data, 'release');
    this._input.on('keydown', this._onKeyDown);
    this._input.on('keyup', this._onKeyUp);
    // Capture references by value so dispose removes the correct handlers
    const boundKeyDown = this._onKeyDown;
    const boundKeyUp = this._onKeyUp;
    this._addDisposable(() => {
      this._input.off('keydown', boundKeyDown);
      this._input.off('keyup', boundKeyUp);
    });

    countdown.setAttribute('aria-live', 'assertive');
    countdown.setAttribute('role', 'timer');
    let count = 3;
    countdown.textContent = count;
    panel.appendChild(countdown);

    const tick = () => {
      count--;
      if (count > 0) {
        countdown.textContent = count;
        this._addTimeout(tick, ComboDrillMode.COUNTDOWN_INTERVAL_MS);
      } else {
        this._prepareStep();
      }
    };
    this._addTimeout(tick, ComboDrillMode.COUNTDOWN_INTERVAL_MS);
  }

  // --- Step State Machine ---

  _prepareStep() {
    const combo = this._selectedCombo;
    if (!combo) return;

    // Check if all repeats done
    if (this._currentRepeat >= combo.repeatCount) {
      this.stop();
      return;
    }

    // Check if all steps in current repeat done
    if (this._currentStepIndex >= combo.steps.length) {
      this._currentStepIndex = 0;
      this._currentRepeat++;
      if (this._currentRepeat >= combo.repeatCount) {
        this.stop();
        return;
      }
    }

    this._showStepUI();

    // Small delay before accepting input
    this._addTimeout(() => {
      if (this._state !== 'running') return;
      const step = combo.steps[this._currentStepIndex];
      this._stepStartTime = this._clock.now();
      this._waitingForInput = true;
      this._firstKeyTime = 0;

      this._resolvedKeys = this._resolveStepKeys(step.keys);
      this._pendingKeys = new Set(this._resolvedKeys);

      // maxDuration timeout
      this._addTimeout(() => {
        if (this._waitingForInput && this._state === 'running') {
          this._completeStep(false);
        }
      }, step.maxDuration);
    }, ComboDrillMode.STEP_DELAY_MS);
  }

  _handleStepKey(data, eventAction) {
    if (!this._waitingForInput || this._state !== 'running') return;

    const combo = this._selectedCombo;
    if (!combo) return;
    const step = combo.steps[this._currentStepIndex];

    // Only handle matching action type (press for keydown, release for keyup)
    if (step.action !== eventAction) return;

    const code = data.code;
    if (!this._pendingKeys || !this._pendingKeys.has(code)) return;

    const now = this._clock.now();
    if (this._firstKeyTime === 0) {
      this._firstKeyTime = now;
    }

    this._pendingKeys.delete(code);

    if (this._pendingKeys.size === 0) {
      // All keys handled — check simultaneity
      if (step.keys.length > 1 && step.simultaneousWindow > 0) {
        const elapsed = now - this._firstKeyTime;
        if (elapsed <= step.simultaneousWindow) {
          this._completeStep(true);
        } else {
          this._completeStep(false);
        }
      } else {
        this._completeStep(true);
      }
    }
  }

  _completeStep(success) {
    this._waitingForInput = false;
    this._pendingKeys = null;

    const combo = this._selectedCombo;
    const isLastStep = this._currentStepIndex >= combo.steps.length - 1;

    if (isLastStep) {
      // Record repeat result — success only if no steps failed in this repeat
      this._stepResults.push(success && !this._currentRepeatHadFailure);
      this._currentRepeatHadFailure = false;
    } else if (!success) {
      this._currentRepeatHadFailure = true;
    }

    // Show brief feedback
    this._showStepFeedback(success);

    this._addTimeout(() => {
      if (this._state !== 'running') return;
      this._currentStepIndex++;
      this._prepareStep();
    }, ComboDrillMode.STEP_FEEDBACK_MS);
  }

  // --- UI Rendering ---

  _showIdleUI() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.add('drill-panel-idle');

    const header = document.createElement('div');
    header.className = 'drill-header';
    const titleSpan = document.createElement('span');
    titleSpan.textContent = 'Combo Drill';
    header.appendChild(titleSpan);
    panel.appendChild(header);

    panel.appendChild(this._renderTechniqueList());

    if (this._selectedCombo && this._unlockedCombos.has(this._selectedCombo.id)) {
      this._renderComboDetails(panel, this._selectedCombo);
    }
  }

  _renderTechniqueList() {
    const list = document.createElement('div');
    list.className = 'combo-technique-list';
    list.setAttribute('role', 'listbox');
    list.setAttribute('aria-label', 'Combo techniques');

    for (const combo of COMBOS) {
      const card = document.createElement('div');
      card.className = 'combo-technique-card';
      const isUnlocked = this._unlockedCombos.has(combo.id);

      card.setAttribute('role', 'option');
      card.setAttribute('tabindex', isUnlocked ? '0' : '-1');

      if (!isUnlocked) {
        card.classList.add('locked');
        card.setAttribute('aria-disabled', 'true');
        card.title = 'Complete the previous technique with 80%+ success rate to unlock';
      }

      if (this._selectedCombo && this._selectedCombo.id === combo.id) {
        card.classList.add('selected');
        card.setAttribute('aria-selected', 'true');
      }

      const name = document.createElement('span');
      name.className = 'combo-technique-name';
      name.textContent = combo.name;
      card.appendChild(name);

      if (isUnlocked) {
        const data = this._appData.comboDrill || { techniques: {} };
        const tech = data.techniques[combo.id];
        if (tech && tech.attempts > 0) {
          const rate = document.createElement('span');
          rate.className = 'combo-technique-rate';
          rate.textContent = Math.round(tech.successRate * 100) + '%';
          card.appendChild(rate);
        }

        const selectHandler = () => {
          this._selectedCombo = combo;
          this._showIdleUI();
        };
        card.addEventListener('click', selectHandler);
        card.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            selectHandler();
          }
        });
      } else {
        const lock = document.createElement('span');
        lock.className = 'combo-technique-lock';
        lock.textContent = 'LOCKED';
        card.appendChild(lock);
      }

      list.appendChild(card);
    }
    return list;
  }

  _renderComboDetails(panel, combo) {
    const desc = document.createElement('div');
    desc.className = 'combo-description';
    desc.textContent = combo.description;
    panel.appendChild(desc);

    const demoArea = document.createElement('div');
    demoArea.className = 'combo-demo-area';
    this._renderDemoSteps(demoArea, combo);
    panel.appendChild(demoArea);

    const repeatInfo = document.createElement('div');
    repeatInfo.className = 'combo-repeat-indicator';
    repeatInfo.textContent = '× ' + combo.repeatCount + ' repeats';
    panel.appendChild(repeatInfo);

    const startBtn = document.createElement('button');
    startBtn.className = 'drill-btn';
    startBtn.textContent = 'Start Drill';
    startBtn.addEventListener('click', () => this.start());
    panel.appendChild(startBtn);

    const demoBtn = document.createElement('button');
    demoBtn.className = 'drill-btn drill-btn-secondary';
    demoBtn.textContent = 'Watch Demo';
    demoBtn.addEventListener('click', () => this._playDemo());
    panel.appendChild(demoBtn);
  }

  _renderDemoSteps(container, combo) {
    const resolvedSteps = combo.steps.map(s => this._resolveStepKeys(s.keys));
    for (let i = 0; i < combo.steps.length; i++) {
      if (i > 0) {
        const arrow = document.createElement('span');
        arrow.className = 'combo-demo-arrow';
        arrow.textContent = '→';
        container.appendChild(arrow);
      }
      const step = combo.steps[i];
      const stepEl = document.createElement('span');
      stepEl.className = 'combo-demo-step';
      stepEl.dataset.stepIndex = i;

      const actionSpan = document.createElement('span');
      actionSpan.className = 'step-action';
      actionSpan.textContent = step.action === 'press' ? '▼' : '▲';

      const keysSpan = document.createElement('span');
      keysSpan.className = 'step-keys';
      keysSpan.textContent = resolvedSteps[i].map(k => this._input.getKeySymbol(k)).join('+');

      stepEl.appendChild(actionSpan);
      stepEl.appendChild(keysSpan);
      container.appendChild(stepEl);
    }
  }

  _playDemo() {
    if (this._demoAnimating) return;
    this._demoAnimating = true;

    const combo = this._selectedCombo;
    if (!combo) return;

    const demoArea = this._drillPanel.querySelector('.combo-demo-area');
    if (!demoArea) return;

    const stepEls = demoArea.querySelectorAll('.combo-demo-step');
    let stepIndex = 0;

    const animateStep = () => {
      if (stepIndex >= stepEls.length || !this._demoAnimating) {
        // Reset all steps
        stepEls.forEach(el => { el.classList.remove('active', 'done'); });
        this._demoAnimating = false;
        return;
      }

      // Mark previous as done
      if (stepIndex > 0) stepEls[stepIndex - 1].classList.replace('active', 'done');

      // Activate current
      stepEls[stepIndex].classList.add('active');
      stepIndex++;

      const step = combo.steps[stepIndex - 1];
      const duration = step.maxDuration * ComboDrillMode.DEMO_SPEED_FACTOR;
      this._addTimeout(animateStep, Math.max(duration, 150));
    };

    animateStep();
  }

  _showStepUI() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    const combo = this._selectedCombo;

    // Header with progress
    const header = document.createElement('div');
    header.className = 'drill-header';
    const nameSpan = document.createElement('span');
    nameSpan.textContent = combo.name;
    header.appendChild(nameSpan);
    const progressSpan = document.createElement('span');
    progressSpan.textContent = 'Rep ' + (this._currentRepeat + 1) + '/' + combo.repeatCount;
    header.appendChild(progressSpan);
    panel.appendChild(header);

    // Step progress dots
    const dotsDiv = document.createElement('div');
    dotsDiv.className = 'combo-step-progress';
    for (let i = 0; i < combo.steps.length; i++) {
      const dot = document.createElement('div');
      dot.className = 'combo-step-dot';
      if (i < this._currentStepIndex) dot.classList.add('done');
      else if (i === this._currentStepIndex) dot.classList.add('active');
      dotsDiv.appendChild(dot);
    }
    panel.appendChild(dotsDiv);

    // Current step instruction
    const step = combo.steps[this._currentStepIndex];
    const resolvedKeys = this._resolveStepKeys(step.keys);
    const prompt = document.createElement('div');
    prompt.className = 'drill-prompt';

    const keysDiv = document.createElement('div');
    keysDiv.className = 'drill-prompt-keys';

    const actionLabel = document.createElement('div');
    actionLabel.className = 'drill-prompt-instruction';
    actionLabel.style.marginBottom = '6px';
    actionLabel.textContent = step.action === 'press' ? 'PRESS' : 'RELEASE';

    for (let i = 0; i < resolvedKeys.length; i++) {
      if (i > 0) {
        const plus = document.createElement('span');
        plus.className = 'drill-prompt-plus';
        plus.textContent = '+';
        keysDiv.appendChild(plus);
      }
      const keyEl = document.createElement('div');
      keyEl.className = 'drill-prompt-key';
      keyEl.textContent = this._input.getKeySymbol(resolvedKeys[i]);
      keysDiv.appendChild(keyEl);
    }

    prompt.appendChild(actionLabel);
    prompt.appendChild(keysDiv);
    panel.appendChild(prompt);

    // Demo sequence at bottom
    const demoArea = document.createElement('div');
    demoArea.className = 'combo-demo-area';
    demoArea.style.marginTop = '8px';
    this._renderDemoSteps(demoArea, combo);
    // Highlight current step
    const stepEls = demoArea.querySelectorAll('.combo-demo-step');
    stepEls.forEach((el, idx) => {
      if (idx < this._currentStepIndex) el.classList.add('done');
      else if (idx === this._currentStepIndex) el.classList.add('active');
    });
    panel.appendChild(demoArea);
  }

  _showStepFeedback(success) {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    const combo = this._selectedCombo;

    // Header
    const header = document.createElement('div');
    header.className = 'drill-header';
    const nameSpan = document.createElement('span');
    nameSpan.textContent = combo.name;
    header.appendChild(nameSpan);
    const progressSpan = document.createElement('span');
    progressSpan.textContent = 'Rep ' + (this._currentRepeat + 1) + '/' + combo.repeatCount;
    header.appendChild(progressSpan);
    panel.appendChild(header);

    const feedback = document.createElement('div');
    feedback.className = 'combo-feedback ' + (success ? 'success' : 'fail');
    feedback.textContent = success ? 'GOOD' : 'MISS';
    panel.appendChild(feedback);
  }

  _showPauseUI() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    const prompt = document.createElement('div');
    prompt.className = 'drill-prompt';
    const label = document.createElement('div');
    label.className = 'drill-prompt-instruction';
    label.textContent = 'Paused — Press ESC to resume';
    prompt.appendChild(label);
    panel.appendChild(prompt);
  }

  _showResultUI() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    const combo = this._selectedCombo;

    const title = document.createElement('div');
    title.className = 'drill-result-title';
    title.textContent = combo.name + ' Complete';
    panel.appendChild(title);

    // Stats
    const successCount = this._stepResults.filter(r => r).length;
    const totalRepeats = this._stepResults.length;
    const successRate = totalRepeats > 0 ? Math.round((successCount / totalRepeats) * 100) : 0;

    const stats = document.createElement('div');
    stats.className = 'combo-result-stats';

    const rateStat = this._createStat(successRate + '%', 'Success Rate');
    const successStat = this._createStat(successCount + '/' + totalRepeats, 'Repeats');
    stats.appendChild(rateStat);
    stats.appendChild(successStat);
    panel.appendChild(stats);

    // Unlock notification
    if (this._newUnlock) {
      const unlockMsg = document.createElement('div');
      unlockMsg.className = 'combo-unlock-msg';
      unlockMsg.textContent = this._newUnlock.name + ' Unlocked!';
      panel.appendChild(unlockMsg);
    }

    // Buttons
    const btnGroup = document.createElement('div');
    btnGroup.className = 'drill-btn-group';

    const retryBtn = document.createElement('button');
    retryBtn.className = 'drill-btn';
    retryBtn.textContent = 'Retry';
    retryBtn.addEventListener('click', () => this.start());
    btnGroup.appendChild(retryBtn);

    const backBtn = document.createElement('button');
    backBtn.className = 'drill-btn';
    backBtn.textContent = 'Back';
    backBtn.addEventListener('click', () => {
      this.dispose();
      this._showIdleUI();
    });
    btnGroup.appendChild(backBtn);

    panel.appendChild(btnGroup);
  }

  _createStat(value, label) {
    const div = document.createElement('div');
    div.className = 'combo-result-stat';
    const valEl = document.createElement('div');
    valEl.className = 'combo-result-stat-value';
    valEl.textContent = value;
    const lblEl = document.createElement('div');
    lblEl.className = 'combo-result-stat-label';
    lblEl.textContent = label;
    div.appendChild(valEl);
    div.appendChild(lblEl);
    return div;
  }
}

ComboDrillMode.UNLOCK_THRESHOLD = 0.8;
ComboDrillMode.COUNTDOWN_INTERVAL_MS = 600;
ComboDrillMode.STEP_DELAY_MS = 200;
ComboDrillMode.STEP_FEEDBACK_MS = 500;
ComboDrillMode.DEMO_SPEED_FACTOR = 0.6;
ComboDrillMode.UNLOCK_ORDER = ['jiggle_right', 'strafe_peek_right', 'forward_peek_right', 'alternating_peek'];
// Key display names are now provided by InputManager.getKeySymbol()

// ============================================================
// RhythmDrillMode — BPM-based lean rhythm drill
// ============================================================
class RhythmDrillMode extends ModeLifecycle {
  constructor(inputManager, audioEngine, clock, storage, appData) {
    super('rhythm');
    this._input = inputManager;
    this._audio = audioEngine;
    this._clock = clock;
    this._storage = storage;
    this._appData = appData;
    this._drillPanel = null;

    // BPM state
    this._currentBPM = RhythmDrillMode.BPM_DEFAULT;
    this._progressiveBPM = false;

    // Beat scheduling
    this._schedulerTimerId = null;
    this._nextBeatIndex = 0;
    this._beatTimes = []; // AudioContext.currentTime (seconds) for each beat
    this._timeOffset = 0; // performance.now() - audioCtx.currentTime * 1000

    // Pattern: E(right) → neutral → Q(left) → neutral
    this._pattern = ['right', 'neutral', 'left', 'neutral'];

    // Judgment state
    this._results = [];
    this._currentBeatForJudgment = 0;
    this._inputHandled = false;

    // Audio fallback
    this._silentMode = false;

    // Feedback timer
    this._feedbackTimerId = null;

    // DOM cache (populated in _showDrillUI)
    this._domRefs = {};

    // Score counters (avoid repeated filter() in hot loop)
    this._perfectCount = 0;
    this._goodCount = 0;
    this._missCount = 0;
  }

  enter() {
    super.enter();
    this._drillPanel = document.getElementById('drill-panel');
    this._loadProgress();
    this._showIdleUI();
  }

  async start() {
    if (this._state !== 'idle' && this._state !== 'result') return;

    // Initialize AudioEngine with user gesture
    this._silentMode = false;
    try {
      await this._audio.init();
    } catch (e) {
      console.warn('[RhythmDrill] AudioEngine init failed, switching to silent mode:', e);
      this._silentMode = true;
    }

    super.start();

    this._results = [];
    this._perfectCount = 0;
    this._goodCount = 0;
    this._missCount = 0;
    this._nextBeatIndex = 0;
    this._currentBeatForJudgment = 0;
    this._inputHandled = false;

    this._bindInput();
    this._showCountdown();
  }

  pause() {
    if (this._state !== 'running') return;
    super.pause();
    this._stopScheduler();
    try { this._audio.suspend(); } catch (e) { console.warn('[RhythmDrill] AudioEngine suspend failed:', e); }
    this._showPauseUI();
  }

  async resume() {
    if (this._state !== 'paused') return;

    try {
      await this._audio.resume();
    } catch (e) {
      console.warn('[RhythmDrill] AudioEngine resume failed, switching to silent mode:', e);
      this._silentMode = true;
    }

    super.resume();

    // Recalculate time offset after resume (pause drift)
    this._calculateTimeOffset();
    this._regenerateBeatScheduleFromCurrent();
    this._startScheduler();
    this._showDrillUI();
  }

  stop() {
    if (this._state !== 'running' && this._state !== 'paused') return;
    this._stopScheduler();
    super.stop();
    this._saveProgress();
    this._showResultUI();
  }

  dispose() {
    this._stopScheduler();
    super.dispose();
  }

  // --- Time Management ---

  _calculateTimeOffset() {
    if (this._audio.isReady()) {
      this._timeOffset = this._clock.now() - this._audio.currentTime * 1000;
    } else {
      this._timeOffset = this._clock.now();
    }
  }

  _audioTimeToPerfTime(audioTime) {
    return audioTime * 1000 + this._timeOffset;
  }

  // --- Beat Scheduling ---

  _generateBeatSchedule() {
    const totalBeats = RhythmDrillMode.WARMUP_BEATS + RhythmDrillMode.BEATS_PER_SET;
    const beatIntervalSec = 60 / this._currentBPM;
    const startTime = this._audio.isReady()
      ? this._audio.currentTime + 0.3
      : this._clock.now() / 1000 + 0.3;

    this._beatTimes = [];
    for (let i = 0; i < totalBeats; i++) {
      this._beatTimes.push(startTime + i * beatIntervalSec);
    }
    this._nextBeatIndex = 0;
  }

  _regenerateBeatScheduleFromCurrent() {
    const remaining = this._beatTimes.length - this._currentBeatForJudgment;
    if (remaining <= 0) return;

    const beatIntervalSec = 60 / this._currentBPM;
    const startTime = this._audio.isReady()
      ? this._audio.currentTime + 0.15
      : this._clock.now() / 1000 + 0.15;

    for (let i = 0; i < remaining; i++) {
      this._beatTimes[this._currentBeatForJudgment + i] = startTime + i * beatIntervalSec;
    }
    this._nextBeatIndex = this._currentBeatForJudgment;
  }

  _startScheduler() {
    this._stopScheduler();
    const lookaheadSec = RhythmDrillMode.LOOKAHEAD_MS / 1000;

    this._schedulerTimerId = this._addInterval(() => {
      if (this._state !== 'running') return;

      const now = this._audio.isReady() ? this._audio.currentTime : this._clock.now() / 1000;

      // Schedule upcoming beats for audio playback
      while (this._nextBeatIndex < this._beatTimes.length &&
             this._beatTimes[this._nextBeatIndex] < now + lookaheadSec) {
        if (this._audio.isReady() && !this._silentMode) {
          this._audio.playBeat(this._beatTimes[this._nextBeatIndex]);
        }
        this._nextBeatIndex++;
      }

      // Check for missed beats and update UI
      this._checkCurrentBeat();
    }, RhythmDrillMode.SCHEDULER_INTERVAL_MS);
  }

  _stopScheduler() {
    if (this._schedulerTimerId !== null) {
      this._clearTimer(this._schedulerTimerId);
      this._schedulerTimerId = null;
    }
  }

  _checkCurrentBeat() {
    const totalBeats = this._beatTimes.length;
    const currentPerfTime = this._clock.now();

    while (this._currentBeatForJudgment < totalBeats) {
      const beatTime = this._beatTimes[this._currentBeatForJudgment];
      const beatPerfTime = this._audioTimeToPerfTime(beatTime);
      const timeSinceBeat = currentPerfTime - beatPerfTime;

      // Past the judgment window — record miss if not handled
      if (timeSinceBeat > RhythmDrillMode.GOOD_THRESHOLD_MS + 50) {
        if (this._currentBeatForJudgment >= RhythmDrillMode.WARMUP_BEATS && !this._inputHandled) {
          this._recordResult(this._currentBeatForJudgment, 'miss', timeSinceBeat);
          this._showTimingFeedback('miss', timeSinceBeat);
        }
        this._currentBeatForJudgment++;
        this._inputHandled = false;

        if (this._currentBeatForJudgment >= totalBeats) {
          this.stop();
          return;
        }
        this._updateDrillDisplay();
      } else {
        // Beat is in active window or upcoming — update UI
        if (timeSinceBeat >= -200) {
          this._updateDrillDisplay();
        }
        break;
      }
    }
  }

  // --- Input Handling ---

  _bindInput() {
    if (this._onLeanChange) {
      this._input.off('leanchange', this._onLeanChange);
    }

    this._onLeanChange = (data) => this._handleLeanChange(data);
    this._input.on('leanchange', this._onLeanChange);

    const boundLeanChange = this._onLeanChange;
    this._addDisposable(() => {
      this._input.off('leanchange', boundLeanChange);
    });
  }

  _handleLeanChange(data) {
    if (this._state !== 'running' || this._inputHandled) return;

    const beatIndex = this._currentBeatForJudgment;
    if (beatIndex >= this._beatTimes.length) return;
    if (beatIndex < RhythmDrillMode.WARMUP_BEATS) return;

    const patternIndex = beatIndex % this._pattern.length;
    const expected = this._pattern[patternIndex];
    const actual = data.newState;

    if (actual !== expected) return;

    // Calculate timing accuracy
    const beatTime = this._beatTimes[beatIndex];
    const beatPerfTime = this._audioTimeToPerfTime(beatTime);
    const inputTime = this._clock.now();
    const timingDiff = Math.abs(inputTime - beatPerfTime);

    let judgment;
    if (timingDiff <= RhythmDrillMode.PERFECT_THRESHOLD_MS) {
      judgment = 'perfect';
    } else if (timingDiff <= RhythmDrillMode.GOOD_THRESHOLD_MS) {
      judgment = 'good';
    } else {
      judgment = 'miss';
    }

    this._recordResult(beatIndex, judgment, timingDiff);
    this._inputHandled = true;
    this._showTimingFeedback(judgment, timingDiff);
  }

  _recordResult(beatIndex, judgment, timingMs) {
    this._results.push({ beatIndex, judgment, timing: timingMs });
    if (judgment === 'perfect') this._perfectCount++;
    else if (judgment === 'good') this._goodCount++;
    else this._missCount++;
  }

  // --- Progress ---

  _loadProgress() {
    const data = this._appData.rhythmDrill || { maxBPM: 60, perfectRate: 0 };
    // Don't override user's BPM selection, just load stats
    this._maxBPM = data.maxBPM || RhythmDrillMode.BPM_MIN;
  }

  _saveProgress() {
    if (this._results.length === 0) return;

    const perfectCount = this._results.filter(r => r.judgment === 'perfect').length;
    const goodCount = this._results.filter(r => r.judgment === 'good').length;
    const totalJudged = this._results.length;
    const successRate = totalJudged > 0 ? (perfectCount + goodCount) / totalJudged : 0;
    const perfectRate = totalJudged > 0 ? perfectCount / totalJudged : 0;

    const data = this._appData.rhythmDrill || { maxBPM: 60, perfectRate: 0, attempts: 0 };

    // Update max BPM if advancing
    if (successRate >= RhythmDrillMode.BPM_ADVANCE_RATE) {
      const nextBPM = Math.min(this._currentBPM + RhythmDrillMode.BPM_STEP, RhythmDrillMode.BPM_MAX);
      if (nextBPM > (data.maxBPM || 0)) {
        data.maxBPM = nextBPM;
      }
    }

    // Rolling average perfect rate
    const prevAttempts = data.attempts || 0;
    data.perfectRate = prevAttempts === 0
      ? perfectRate
      : (data.perfectRate * prevAttempts + perfectRate) / (prevAttempts + 1);
    data.attempts = prevAttempts + 1;
    data.lastBPM = this._currentBPM;

    this._appData.rhythmDrill = data;
    this._storage.save(this._appData);
    this._maxBPM = data.maxBPM;
  }

  // --- UI ---

  _showIdleUI() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.add('drill-panel-idle');

    const header = document.createElement('div');
    header.className = 'drill-header';
    const titleSpan = document.createElement('span');
    titleSpan.textContent = 'Rhythm Drill';
    header.appendChild(titleSpan);
    panel.appendChild(header);

    const desc = document.createElement('div');
    desc.className = 'combo-description';
    const rSym = this._input.getKeySymbol(this._input.getLeanKeyForDirection('right'));
    const lSym = this._input.getKeySymbol(this._input.getLeanKeyForDirection('left'));
    desc.textContent = 'BPMに合わせて' + rSym + '→戻→' + lSym + '→戻のリーン操作を繰り返します。ビートに合わせて正確に入力しましょう。';
    panel.appendChild(desc);

    panel.appendChild(this._createPatternPreview());

    // BPM slider
    const bpmContainer = document.createElement('div');
    bpmContainer.className = 'rhythm-bpm-container';

    const bpmLabel = document.createElement('label');
    bpmLabel.className = 'rhythm-bpm-label';
    bpmLabel.htmlFor = 'rhythm-bpm';
    bpmLabel.textContent = 'BPM: ' + this._currentBPM;

    const bpmSlider = document.createElement('input');
    bpmSlider.type = 'range';
    bpmSlider.id = 'rhythm-bpm';
    bpmSlider.className = 'rhythm-bpm-slider';
    bpmSlider.min = RhythmDrillMode.BPM_MIN;
    bpmSlider.max = RhythmDrillMode.BPM_MAX;
    bpmSlider.step = RhythmDrillMode.BPM_STEP;
    bpmSlider.value = this._currentBPM;
    bpmSlider.setAttribute('aria-label', 'BPM');
    bpmSlider.addEventListener('input', () => {
      this._currentBPM = parseInt(bpmSlider.value, 10);
      bpmLabel.textContent = 'BPM: ' + this._currentBPM;
    });

    bpmContainer.appendChild(bpmLabel);
    bpmContainer.appendChild(bpmSlider);
    panel.appendChild(bpmContainer);

    // Max BPM display
    const data = this._appData.rhythmDrill || {};
    if (this._maxBPM > RhythmDrillMode.BPM_MIN) {
      const maxInfo = document.createElement('div');
      maxInfo.className = 'rhythm-max-bpm';
      maxInfo.textContent = 'Best: ' + this._maxBPM + ' BPM';
      if (data.perfectRate !== undefined && data.attempts > 0) {
        maxInfo.textContent += ' | Perfect: ' + Math.round(data.perfectRate * 100) + '%';
      }
      panel.appendChild(maxInfo);
    }

    // Progressive BPM checkbox
    const progressiveContainer = document.createElement('div');
    progressiveContainer.className = 'rhythm-progressive-container';
    const progressiveCheck = document.createElement('input');
    progressiveCheck.type = 'checkbox';
    progressiveCheck.id = 'rhythm-progressive';
    progressiveCheck.checked = this._progressiveBPM;
    progressiveCheck.addEventListener('change', () => {
      this._progressiveBPM = progressiveCheck.checked;
      if (this._progressiveBPM) {
        this._currentBPM = RhythmDrillMode.BPM_MIN;
        bpmSlider.value = this._currentBPM;
        bpmLabel.textContent = 'BPM: ' + this._currentBPM;
        bpmSlider.disabled = true;
      } else {
        bpmSlider.disabled = false;
      }
    });
    const progressiveLabel = document.createElement('label');
    progressiveLabel.htmlFor = 'rhythm-progressive';
    progressiveLabel.textContent = '段階的BPM（60BPMから自動加速）';
    progressiveContainer.appendChild(progressiveCheck);
    progressiveContainer.appendChild(progressiveLabel);
    panel.appendChild(progressiveContainer);

    // Start button
    const startBtn = document.createElement('button');
    startBtn.className = 'drill-btn';
    startBtn.textContent = 'Start Drill';
    startBtn.addEventListener('click', () => this.start());
    panel.appendChild(startBtn);
  }

  _createPatternPreview() {
    const patternDiv = document.createElement('div');
    patternDiv.className = 'combo-demo-area';
    const rightKey = this._input.getLeanKeyForDirection('right');
    const leftKey = this._input.getLeanKeyForDirection('left');
    const steps = [
      { label: this._input.getKeySymbol(rightKey), desc: 'Lean R' },
      { label: '—', desc: 'Center' },
      { label: this._input.getKeySymbol(leftKey), desc: 'Lean L' },
      { label: '—', desc: 'Center' }
    ];
    for (let i = 0; i < steps.length; i++) {
      if (i > 0) {
        const arrow = document.createElement('span');
        arrow.className = 'combo-demo-arrow';
        arrow.textContent = '→';
        patternDiv.appendChild(arrow);
      }
      const stepEl = document.createElement('span');
      stepEl.className = 'combo-demo-step';
      const keysSpan = document.createElement('span');
      keysSpan.className = 'step-keys';
      keysSpan.textContent = steps[i].label;
      stepEl.appendChild(keysSpan);
      patternDiv.appendChild(stepEl);
    }
    return patternDiv;
  }

  _showCountdown() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    const countdown = document.createElement('div');
    countdown.className = 'drill-countdown';
    countdown.setAttribute('aria-live', 'assertive');
    countdown.setAttribute('role', 'timer');

    let count = 3;
    countdown.textContent = count;
    panel.appendChild(countdown);

    const tick = () => {
      count--;
      if (count > 0) {
        countdown.textContent = count;
        this._addTimeout(tick, RhythmDrillMode.COUNTDOWN_INTERVAL_MS);
      } else {
        this._startDrill();
      }
    };
    this._addTimeout(tick, RhythmDrillMode.COUNTDOWN_INTERVAL_MS);
  }

  _startDrill() {
    this._calculateTimeOffset();
    this._generateBeatSchedule();
    this._startScheduler();
    this._showDrillUI();
  }

  _showDrillUI() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    // Header with BPM
    const header = document.createElement('div');
    header.className = 'drill-header';
    const nameSpan = document.createElement('span');
    nameSpan.textContent = 'Rhythm Drill';
    header.appendChild(nameSpan);
    const bpmSpan = document.createElement('span');
    bpmSpan.textContent = this._currentBPM + ' BPM';
    header.appendChild(bpmSpan);
    panel.appendChild(header);

    // Beat progress
    const progressDiv = document.createElement('div');
    progressDiv.className = 'rhythm-beat-progress';
    progressDiv.id = 'rhythm-progress';
    panel.appendChild(progressDiv);

    // Current instruction
    const prompt = document.createElement('div');
    prompt.className = 'drill-prompt';

    const instruction = document.createElement('div');
    instruction.className = 'drill-prompt-instruction';
    instruction.id = 'rhythm-instruction';

    const keyDisplay = document.createElement('div');
    keyDisplay.className = 'drill-prompt-keys';
    keyDisplay.id = 'rhythm-key-display';

    prompt.appendChild(instruction);
    prompt.appendChild(keyDisplay);
    panel.appendChild(prompt);

    // Feedback area
    const feedback = document.createElement('div');
    feedback.className = 'rhythm-feedback';
    feedback.id = 'rhythm-feedback';
    feedback.setAttribute('aria-live', 'polite');
    panel.appendChild(feedback);

    // Score area
    const scoreDiv = document.createElement('div');
    scoreDiv.className = 'rhythm-score';
    scoreDiv.id = 'rhythm-score';
    panel.appendChild(scoreDiv);

    // Beat indicator bar
    const beatIndicator = document.createElement('div');
    beatIndicator.className = 'rhythm-beat-indicator';
    beatIndicator.id = 'rhythm-beat-indicator';
    const flash = document.createElement('div');
    flash.className = 'beat-flash';
    beatIndicator.appendChild(flash);
    panel.appendChild(beatIndicator);

    // Cache DOM refs for hot-loop access
    this._domRefs = {
      progress: progressDiv,
      instruction: instruction,
      keyDisplay: keyDisplay,
      score: scoreDiv,
      feedback: feedback,
      flash: flash
    };

    this._updateDrillDisplay();
  }

  _updateDrillDisplay() {
    const refs = this._domRefs;
    if (!refs.progress || !refs.instruction || !refs.keyDisplay) return;

    const currentBeat = this._currentBeatForJudgment;
    this._updateDrillProgress(refs, currentBeat);
    this._updateDrillInstruction(refs, currentBeat);
    this._updateDrillScore(refs);
    this._updateBeatFlash(refs, currentBeat);
  }

  _updateDrillProgress(refs, currentBeat) {
    const warmup = RhythmDrillMode.WARMUP_BEATS;
    refs.progress.textContent = currentBeat < warmup
      ? 'Warm-up ' + (currentBeat + 1) + '/' + warmup
      : 'Beat ' + (currentBeat - warmup + 1) + '/' + RhythmDrillMode.BEATS_PER_SET;
  }

  _updateDrillInstruction(refs, currentBeat) {
    const patternIndex = currentBeat % this._pattern.length;
    const expected = this._pattern[patternIndex];
    refs.instruction.textContent = this._getInstructionText(expected);

    refs.keyDisplay.textContent = '';
    const keyEl = document.createElement('div');
    keyEl.className = 'drill-prompt-key';
    if (expected === 'right') {
      const rightKey = this._input.getLeanKeyForDirection('right');
      keyEl.textContent = this._input.getKeySymbol(rightKey);
      keyEl.classList.add('active');
    } else if (expected === 'left') {
      const leftKey = this._input.getLeanKeyForDirection('left');
      keyEl.textContent = this._input.getKeySymbol(leftKey);
      keyEl.classList.add('active');
    } else {
      keyEl.textContent = '—';
      keyEl.style.opacity = '0.4';
    }
    refs.keyDisplay.appendChild(keyEl);
  }

  _updateDrillScore(refs) {
    if (refs.score) {
      refs.score.textContent = 'P:' + this._perfectCount + ' G:' + this._goodCount + ' M:' + this._missCount;
    }
  }

  _updateBeatFlash(refs, currentBeat) {
    const beatPerfTime = this._audioTimeToPerfTime(this._beatTimes[currentBeat]);
    const now = this._clock.now();
    if (refs.flash) {
      const sinceBeat = now - beatPerfTime;
      refs.flash.classList.toggle('active', sinceBeat >= 0 && sinceBeat < 100);
    }
  }

  _getInstructionText(expected) {
    switch (expected) {
      case 'right': return 'LEAN RIGHT';
      case 'left': return 'LEAN LEFT';
      case 'neutral': return 'CENTER';
      default: return '';
    }
  }

  _showTimingFeedback(judgment, timingMs) {
    const feedback = this._domRefs.feedback;
    if (!feedback) return;

    const labels = { perfect: 'PERFECT', good: 'GOOD', miss: 'MISS' };
    const colors = {
      perfect: 'var(--accent-turquoise)',
      good: 'var(--accent-yellow)',
      miss: 'var(--accent-red)'
    };

    feedback.textContent = labels[judgment] + ' (' + Math.round(timingMs) + 'ms)';
    feedback.style.color = colors[judgment];
    feedback.style.opacity = '1';

    if (this._feedbackTimerId !== null) {
      this._clearTimer(this._feedbackTimerId);
    }
    this._feedbackTimerId = this._addTimeout(() => {
      if (feedback) feedback.style.opacity = '0.3';
      this._feedbackTimerId = null;
    }, 400);
  }

  _showPauseUI() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    const prompt = document.createElement('div');
    prompt.className = 'drill-prompt';
    const label = document.createElement('div');
    label.className = 'drill-prompt-instruction';
    label.textContent = 'Paused — Press ESC to resume';
    prompt.appendChild(label);
    panel.appendChild(prompt);
  }

  _showResultUI() {
    const panel = this._drillPanel;
    panel.textContent = '';
    panel.classList.remove('drill-panel-idle');

    const title = document.createElement('div');
    title.className = 'drill-result-title';
    title.textContent = 'Rhythm Drill Complete';
    panel.appendChild(title);

    const totalJudged = this._results.length;
    const perfectCount = this._perfectCount;
    const goodCount = this._goodCount;
    const missCount = this._missCount;
    const successCount = perfectCount + goodCount;
    const successRate = totalJudged > 0 ? Math.round((successCount / totalJudged) * 100) : 0;
    const avgTiming = totalJudged > 0
      ? Math.round(this._results.reduce((sum, r) => sum + r.timing, 0) / totalJudged)
      : 0;

    const stats = document.createElement('div');
    stats.className = 'combo-result-stats';
    stats.appendChild(this._createStat(this._currentBPM + '', 'BPM'));
    stats.appendChild(this._createStat(successRate + '%', 'Success'));
    stats.appendChild(this._createStat(avgTiming + 'ms', 'Avg Timing'));
    panel.appendChild(stats);

    // Detailed breakdown
    const breakdown = document.createElement('div');
    breakdown.className = 'rhythm-breakdown';
    const pStat = document.createElement('span');
    pStat.style.color = 'var(--accent-turquoise)';
    pStat.textContent = 'Perfect: ' + perfectCount;
    const gStat = document.createElement('span');
    gStat.style.color = 'var(--accent-yellow)';
    gStat.textContent = 'Good: ' + goodCount;
    const mStat = document.createElement('span');
    mStat.style.color = 'var(--accent-red)';
    mStat.textContent = 'Miss: ' + missCount;
    breakdown.appendChild(pStat);
    breakdown.appendChild(gStat);
    breakdown.appendChild(mStat);
    panel.appendChild(breakdown);

    // BPM advancement
    if (successRate >= RhythmDrillMode.BPM_ADVANCE_RATE * 100 && this._progressiveBPM) {
      const nextBPM = Math.min(this._currentBPM + RhythmDrillMode.BPM_STEP, RhythmDrillMode.BPM_MAX);
      if (nextBPM > this._currentBPM) {
        const advance = document.createElement('div');
        advance.className = 'rhythm-advance-msg';
        advance.textContent = 'BPM UP! Next: ' + nextBPM + ' BPM';
        panel.appendChild(advance);
        this._currentBPM = nextBPM;
      }
    }

    // Buttons
    const btnGroup = document.createElement('div');
    btnGroup.className = 'drill-btn-group';

    const retryBtn = document.createElement('button');
    retryBtn.className = 'drill-btn';
    retryBtn.textContent = 'Retry';
    retryBtn.addEventListener('click', () => this.start());
    btnGroup.appendChild(retryBtn);

    const backBtn = document.createElement('button');
    backBtn.className = 'drill-btn';
    backBtn.textContent = 'Back';
    backBtn.addEventListener('click', () => {
      this.dispose();
      this.enter();
    });
    btnGroup.appendChild(backBtn);

    panel.appendChild(btnGroup);
  }

  _createStat(value, label) {
    const div = document.createElement('div');
    div.className = 'combo-result-stat';
    const valEl = document.createElement('div');
    valEl.className = 'combo-result-stat-value';
    valEl.textContent = value;
    const lblEl = document.createElement('div');
    lblEl.className = 'combo-result-stat-label';
    lblEl.textContent = label;
    div.appendChild(valEl);
    div.appendChild(lblEl);
    return div;
  }
}

RhythmDrillMode.BPM_MIN = 60;
RhythmDrillMode.BPM_MAX = 180;
RhythmDrillMode.BPM_DEFAULT = 100;
RhythmDrillMode.BPM_STEP = 10;
RhythmDrillMode.PERFECT_THRESHOLD_MS = 40;
RhythmDrillMode.GOOD_THRESHOLD_MS = 90;
RhythmDrillMode.WARMUP_BEATS = 4;
RhythmDrillMode.BEATS_PER_SET = 16;
RhythmDrillMode.BPM_ADVANCE_RATE = 0.8;
RhythmDrillMode.SCHEDULER_INTERVAL_MS = 25;
RhythmDrillMode.LOOKAHEAD_MS = 200;
RhythmDrillMode.COUNTDOWN_INTERVAL_MS = 600;

// ============================================================
// PlaceholderMode — Stub for unimplemented modes
// ============================================================
class PlaceholderMode extends ModeLifecycle {
  constructor(name, displayName) {
    super(name);
    this._displayName = displayName;
    this._drillPanel = null;
  }

  enter() {
    super.enter();
    this._drillPanel = document.getElementById('drill-panel');
    if (this._drillPanel) {
      this._drillPanel.textContent = '';
      const div = document.createElement('div');
      div.className = 'placeholder';
      div.textContent = this._displayName + ' — COMING SOON';
      this._drillPanel.appendChild(div);
    }
  }

  dispose() {
    super.dispose();
  }
}

// ============================================================
// App Initialization
// ============================================================
(function() {
  let clock, input, storage, appData, renderer, audioEngine, modeManager;
  try {
    clock = new GameClock();
    input = new InputManager();
    storage = new Storage();
    appData = storage.load();
    renderer = new Renderer(document.getElementById('game-canvas'));
    audioEngine = new AudioEngine();
    modeManager = new ModeManager(input, audioEngine);
  } catch (initError) {
    console.error('[App] Initialization failed:', initError);
    const banner = document.getElementById('warning-banner');
    if (banner) {
      banner.textContent = '初期化に失敗しました。ページを再読み込みしてください。';
      banner.classList.add('visible');
    }
    return;
  }

  // Hide canvas overlay now that renderer is active
  const overlay = document.getElementById('canvas-overlay');
  if (overlay) overlay.style.display = 'none';

  // Schema version warning
  if (appData._readOnly) {
    const banner = document.getElementById('warning-banner');
    banner.textContent = 'このデータは新しいバージョンで作成されました。一部機能が正しく動作しない可能性があります。最新版をお使いください。';
    banner.classList.add('visible');
  }

  // Apply saved lean mode
  if (appData.settings && appData.settings.leanMode) {
    input.setLeanMode(appData.settings.leanMode);
  }

  // Apply saved lean direction
  if (appData.settings) {
    input.setLeanDirection(!!appData.settings.useEftStandard);
  }

  // --- UI: Key Indicators ---
  const keyElements = {};
  document.querySelectorAll('.key[data-key]').forEach(el => {
    keyElements[el.dataset.key] = el;
  });

  const leanDisplay = document.getElementById('lean-state-display');
  const statusKeys = document.getElementById('status-keys');
  const statusLean = document.getElementById('status-lean');
  const clockDisplay = document.getElementById('clock-display');

  function updateKeyIndicators(pressedKeys) {
    for (const [code, el] of Object.entries(keyElements)) {
      el.classList.toggle('active', pressedKeys.has(code));
    }
    statusKeys.textContent = 'Keys: ' + pressedKeys.size;
  }

  function updateLeanDisplay(state) {
    const labels = { neutral: 'NEUTRAL', left: '↶ リーン', right: 'リーン ↷' };
    leanDisplay.textContent = labels[state] || 'NEUTRAL';
    leanDisplay.className = '';
    if (state === 'left') leanDisplay.classList.add('lean-left');
    else if (state === 'right') leanDisplay.classList.add('lean-right');
    statusLean.textContent = 'Lean: ' + (labels[state] || 'Neutral');
  }

  input.on('keydown', (data) => updateKeyIndicators(data.pressedKeys));
  input.on('keyup', (data) => updateKeyIndicators(data.pressedKeys));
  input.on('leanchange', (data) => updateLeanDisplay(data.newState));
  input.on('reset', () => {
    updateKeyIndicators(new Set());
    updateLeanDisplay('neutral');
  });

  // --- UI: Lean Mode Toggle ---
  const leanBtns = document.querySelectorAll('.toggle-btn[data-lean-mode]');
  leanBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const mode = btn.dataset.leanMode;
      input.setLeanMode(mode);
      leanBtns.forEach(b => b.classList.toggle('active', b.dataset.leanMode === mode));
      appData.settings.leanMode = mode;
      storage.save(appData);
    });

    if (btn.dataset.leanMode === input.leanMode) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });

  // --- UI: Lean Direction Toggle ---
  const leanDirBtns = document.querySelectorAll('.toggle-btn[data-lean-dir]');
  leanDirBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const isStandard = btn.dataset.leanDir === 'standard';
      input.setLeanDirection(isStandard);
      leanDirBtns.forEach(b => {
        const bIsStandard = b.dataset.leanDir === 'standard';
        const isActive = bIsStandard === isStandard;
        b.classList.toggle('active', isActive);
        b.setAttribute('aria-pressed', String(isActive));
      });
      appData.settings.useEftStandard = isStandard;
      storage.save(appData);
    });

    const isStandard = btn.dataset.leanDir === 'standard';
    const isActive = isStandard === !!appData.settings.useEftStandard;
    btn.classList.toggle('active', isActive);
    btn.setAttribute('aria-pressed', String(isActive));
  });

  // --- Register Modes ---
  const freeMode = new FreePracticeMode(renderer, input, clock, storage);
  const reactionMode = new ReactionDrillMode(input, clock, storage, appData);
  const comboMode = new ComboDrillMode(input, clock, storage, appData);
  const rhythmMode = new RhythmDrillMode(input, audioEngine, clock, storage, appData);

  modeManager.register('free', freeMode);
  modeManager.register('reaction', reactionMode);
  modeManager.register('combo', comboMode);
  modeManager.register('rhythm', rhythmMode);

  // --- UI: Mode Select ---
  const modeSelect = document.getElementById('mode-select');
  const statusMode = document.getElementById('status-mode');
  const drillPanel = document.getElementById('drill-panel');
  const modeLabels = {
    free: 'Free Practice',
    reaction: 'Key Reaction',
    combo: 'Combo Drill',
    rhythm: 'Rhythm Drill'
  };

  modeSelect.addEventListener('change', () => {
    const modeName = modeSelect.value;
    statusMode.textContent = 'Mode: ' + (modeLabels[modeName] || modeName);
    modeManager.switchTo(modeName);
  });

  // --- Canvas Resize & Clock ---
  renderer.resize();

  // Clock display loop (always runs, independent of mode)
  function clockLoop() {
    clockDisplay.textContent = (clock.elapsed() / 1000).toFixed(3) + 's';
    requestAnimationFrame(clockLoop);
  }
  requestAnimationFrame(clockLoop);

  // --- Esc key pause handling ---
  input.on('keydown', (data) => {
    if (data.code === 'Escape' && modeManager.currentMode) {
      const mode = modeManager.currentMode;
      if (mode.state === 'running') {
        mode.pause();
      } else if (mode.state === 'paused') {
        mode.resume();
      }
    }
  });

  // --- UI: Data Reset Button ---
  const btnDataReset = document.getElementById('btn-data-reset');
  btnDataReset.addEventListener('click', () => {
    if (confirm('すべてのデータをリセットしますか？この操作は取り消せません。')) {
      try {
        storage.clear();
      } catch (e) {
        console.error('Failed to clear storage:', e);
      }
      location.reload();
    }
  });

  // --- KRO Diagnostic ---
  const kroOverlay = document.getElementById('kro-diagnostic');
  const kroInstruction = document.getElementById('kro-instruction');
  const kroKeyDisplay = document.getElementById('kro-key-display');
  const kroStatus = document.getElementById('kro-status');
  const kroResult = document.getElementById('kro-result');
  const kroCloseBtn = document.getElementById('kro-close');
  const btnKroDiag = document.getElementById('btn-kro-diagnostic');

  if (!kroOverlay || !kroInstruction || !kroKeyDisplay || !kroStatus || !kroResult || !kroCloseBtn || !btnKroDiag) {
    console.error('KRO diagnostic: required DOM elements not found');
  }

  // Combos chosen to cover WASD+QE matrix positions that commonly ghost on membrane keyboards.
  // Each combo tests 3-key rollover across different matrix rows/columns.
  const KRO_TEST_COMBOS = [
    ['KeyW', 'KeyD', 'KeyE'],
    ['KeyW', 'KeyA', 'KeyQ'],
    ['KeyA', 'KeyS', 'KeyQ'],
    ['KeyD', 'KeyS', 'KeyE'],
    ['KeyW', 'KeyA', 'KeyD'],
    ['KeyW', 'KeyS', 'KeyE'],
  ];

  const KEY_LABELS = {
    KeyW: 'W', KeyA: 'A', KeyS: 'S', KeyD: 'D', KeyQ: 'Q', KeyE: 'E'
  };

  const KRO_DELAY_SUCCESS = 400;
  const KRO_DELAY_FAIL = 800;

  let kroActive = false;
  let kroTestIndex = 0;
  let kroDetectedKeys = new Set();
  let kroHeldKeys = new Set();
  let kroResults = [];
  let kroMaxSimultaneous = 0;
  let kroFailedCombos = [];
  let kroTimerId = null;

  function kroStartTest() {
    kroTestIndex = 0;
    kroResults = [];
    kroMaxSimultaneous = 0;
    kroFailedCombos = [];
    kroResult.classList.add('kro-result-hidden');
    kroShowCombo();
  }

  function kroShowCombo() {
    if (kroTestIndex >= KRO_TEST_COMBOS.length) {
      kroShowResults();
      return;
    }

    const combo = KRO_TEST_COMBOS[kroTestIndex];
    kroDetectedKeys = new Set();

    kroInstruction.textContent = '以下の ' + combo.length + ' キーを同時に押してください (' + (kroTestIndex + 1) + '/' + KRO_TEST_COMBOS.length + ')';
    kroStatus.textContent = 'Waiting for input...';

    kroKeyDisplay.textContent = '';
    combo.forEach((code, i) => {
      const keyEl = document.createElement('div');
      keyEl.className = 'kro-key';
      keyEl.id = 'kro-key-' + code;
      keyEl.textContent = KEY_LABELS[code] || code;
      kroKeyDisplay.appendChild(keyEl);
      if (i < combo.length - 1) {
        const plus = document.createElement('div');
        plus.className = 'kro-plus';
        plus.textContent = '+';
        kroKeyDisplay.appendChild(plus);
      }
    });
  }

  function kroHandleKeyDown(e) {
    if (!kroActive) return;
    if (e.code === 'Escape') { kroClose(); return; }
    e.preventDefault();
    const combo = KRO_TEST_COMBOS[kroTestIndex];
    if (!combo) return;

    if (combo.includes(e.code)) {
      kroDetectedKeys.add(e.code);
      kroHeldKeys.add(e.code);
      const keyEl = document.getElementById('kro-key-' + e.code);
      if (keyEl) keyEl.classList.add('detected');
      kroStatus.textContent = kroDetectedKeys.size + '/' + combo.length + ' keys detected';
    }
  }

  function kroHandleKeyUp(e) {
    if (!kroActive) return;
    if (e.code === 'Escape') return;
    e.preventDefault();
    const combo = KRO_TEST_COMBOS[kroTestIndex];
    if (!combo) return;

    kroHeldKeys.delete(e.code);

    // Evaluate only after all held combo keys are released
    const anyComboKeyHeld = combo.some(c => kroHeldKeys.has(c));
    if (!anyComboKeyHeld && kroDetectedKeys.size > 0) {
      const detected = kroDetectedKeys.size;
      const total = combo.length;
      const success = detected === total;

      kroResults.push({
        combo: combo.map(c => KEY_LABELS[c]).join('+'),
        codes: [...combo],
        detected,
        total,
        success
      });

      if (detected > kroMaxSimultaneous) kroMaxSimultaneous = detected;
      if (!success) {
        kroFailedCombos.push(combo.map(c => KEY_LABELS[c]).join('+'));
        combo.forEach(code => {
          const keyEl = document.getElementById('kro-key-' + code);
          if (keyEl && !kroDetectedKeys.has(code)) keyEl.classList.add('failed');
        });
      }

      kroDetectedKeys = new Set();
      kroHeldKeys = new Set();
      kroTestIndex++;

      kroTimerId = setTimeout(() => kroShowCombo(), success ? KRO_DELAY_SUCCESS : KRO_DELAY_FAIL);
    }
  }

  function kroShowResults() {
    const allSuccess = kroFailedCombos.length === 0;
    const maxKeys = allSuccess ? 3 : kroMaxSimultaneous;

    kroInstruction.textContent = '';
    kroKeyDisplay.textContent = '';
    kroStatus.textContent = '';
    kroResult.classList.remove('kro-result-hidden');
    kroResult.textContent = '';

    const title = document.createElement('div');
    title.className = 'kro-result-title';
    title.textContent = 'Diagnostic Complete';
    kroResult.appendChild(title);

    const maxDisplay = document.createElement('div');
    maxDisplay.className = 'kro-result-max';
    maxDisplay.textContent = maxKeys + '-KEY';
    kroResult.appendChild(maxDisplay);

    const desc = document.createElement('div');
    desc.className = 'kro-instruction';
    desc.textContent = '推定: お使いのキーボードは ' + maxKeys + ' キー同時押しまで対応しています';
    kroResult.appendChild(desc);

    if (kroFailedCombos.length > 0) {
      const failed = document.createElement('div');
      failed.className = 'kro-failed-combos';
      failed.textContent = '検出できなかった組み合わせ: ' + kroFailedCombos.join(', ');
      kroResult.appendChild(failed);
    }

    const note = document.createElement('div');
    note.className = 'kro-result-note';
    note.textContent = '※ キーマトリクス依存のため完全な判定は不可能です。特定のキー組み合わせのみ制限される場合があります。';
    kroResult.appendChild(note);

    // Save results
    appData.kro = appData.kro || { diagnosis: null, failedCombos: {}, drillFailCounts: {} };
    appData.kro.diagnosis = {
      maxSimultaneous: maxKeys,
      failedCombos: kroResults.filter(r => !r.success).map(r => r.codes),
      testedAt: Date.now()
    };
    for (const r of kroResults) {
      if (!r.success) {
        appData.kro.failedCombos[r.codes.sort().join('+')] = true;
      }
    }
    storage.save(appData);
  }

  function kroOpen() {
    kroActive = true;
    kroOverlay.classList.add('active');

    document.addEventListener('keydown', kroHandleKeyDown, true);
    document.addEventListener('keyup', kroHandleKeyUp, true);

    kroStartTest();
    kroCloseBtn.focus();
  }

  function kroClose() {
    kroActive = false;
    if (kroTimerId) { clearTimeout(kroTimerId); kroTimerId = null; }
    kroOverlay.classList.remove('active');

    document.removeEventListener('keydown', kroHandleKeyDown, true);
    document.removeEventListener('keyup', kroHandleKeyUp, true);

    btnKroDiag.focus();
  }

  btnKroDiag.addEventListener('click', kroOpen);
  kroCloseBtn.addEventListener('click', kroClose);

  // --- Initial mode: Free Practice ---
  modeManager.switchTo('free');

  // --- Self-test functions (dev mode) ---
  function createTestContext() {
    const results = [];
    function assert(name, condition) {
      results.push({ name, pass: !!condition });
      console.log(condition ? '[PASS]' : '[FAIL]', name);
    }
    function summary(label) {
      const passed = results.filter(r => r.pass).length;
      const total = results.length;
      console.log('--- ' + label + ': ' + passed + '/' + total + ' passed ---');
      return { passed, total, results };
    }
    return { results, assert, summary };
  }

  async function runAudioEngineTests() {
    const { assert, summary } = createTestContext();

    // Test 1: Initial state
    const testEngine = new AudioEngine();
    assert('initial state is uninitialized', testEngine.state === 'uninitialized');
    assert('isReady returns false before init', testEngine.isReady() === false);
    assert('currentTime is 0 before init', testEngine.currentTime === 0);
    assert('lastError is null initially', testEngine.lastError === null);

    // Test 2: init creates AudioContext
    try {
      await testEngine.init();
      assert('state is running after init', testEngine.state === 'running');
      assert('isReady returns true after init', testEngine.isReady() === true);
      assert('currentTime is a number', typeof testEngine.currentTime === 'number');
    } catch (e) {
      assert('init succeeds (may fail without user gesture)', false);
    }

    // Test 3: suspend
    try {
      await testEngine.suspend();
      assert('state is suspended after suspend', testEngine.state === 'suspended');
      assert('isReady returns false after suspend', testEngine.isReady() === false);
    } catch (e) {
      assert('suspend succeeds', false);
    }

    // Test 4: resume
    try {
      await testEngine.resume();
      assert('state is running after resume', testEngine.state === 'running');
      assert('isReady returns true after resume', testEngine.isReady() === true);
    } catch (e) {
      assert('resume succeeds', false);
    }

    // Test 5: playBeat does not throw
    try {
      testEngine.playBeat(testEngine.currentTime + 0.1);
      assert('playBeat does not throw', true);
    } catch (e) {
      assert('playBeat does not throw', false);
    }

    // Test 6: playBeat is no-op when suspended
    try {
      await testEngine.suspend();
      testEngine.playBeat(testEngine.currentTime + 0.1);
      assert('playBeat is no-op when suspended', true);
    } catch (e) {
      assert('playBeat is no-op when suspended', false);
    }

    // Test 7: destroy
    testEngine.destroy();
    assert('state is uninitialized after destroy', testEngine.state === 'uninitialized');
    assert('isReady returns false after destroy', testEngine.isReady() === false);

    // Test 8: resume/suspend on uninitialized engine is no-op
    const uninitEngine = new AudioEngine();
    try {
      await uninitEngine.resume();
      assert('resume on uninitialized is no-op', true);
    } catch (e) {
      assert('resume on uninitialized is no-op', false);
    }
    try {
      await uninitEngine.suspend();
      assert('suspend on uninitialized is no-op', true);
    } catch (e) {
      assert('suspend on uninitialized is no-op', false);
    }
    uninitEngine.destroy();

    return summary('AudioEngine Tests');
  }

  async function runModeLifecycleTests() {
    const { assert, summary } = createTestContext();

    // --- State transition tests ---
    const mode = new ModeLifecycle('test');
    assert('initial state is idle', mode.state === 'idle');

    mode.enter();
    assert('state is idle after enter', mode.state === 'idle');

    mode.start();
    assert('state is running after start', mode.state === 'running');

    mode.pause();
    assert('state is paused after pause', mode.state === 'paused');

    mode.resume();
    assert('state is running after resume', mode.state === 'running');

    mode.stop();
    assert('state is result after stop', mode.state === 'result');

    mode.start();
    assert('can start from result', mode.state === 'running');

    mode.dispose();
    assert('state is idle after dispose', mode.state === 'idle');

    // --- Invalid transitions ---
    const mode2 = new ModeLifecycle('test2');
    mode2.enter();
    mode2.pause(); // should not change from idle
    assert('pause from idle is no-op', mode2.state === 'idle');

    mode2.resume(); // should not change from idle
    assert('resume from idle is no-op', mode2.state === 'idle');

    mode2.stop(); // should not change from idle
    assert('stop from idle is no-op', mode2.state === 'idle');

    mode2.start();
    mode2.start(); // double start, stays running
    assert('double start stays running', mode2.state === 'running');
    mode2.dispose();

    // --- Resource tracking tests ---
    const mode3 = new ModeLifecycle('test3');
    mode3.enter();
    mode3.start();

    let timerFired = false;
    mode3._addTimeout(() => { timerFired = true; }, 50);
    assert('timer is tracked', mode3._getResourceCounts().timers === 1);

    const intervalId = mode3._addInterval(() => {}, 1000);
    assert('interval is tracked', mode3._getResourceCounts().timers === 2);

    let rafFired = false;
    mode3._addRAF(() => { rafFired = true; });
    assert('raf is tracked', mode3._getResourceCounts().rafs === 1);

    const target = document.createElement('div');
    mode3._addEventListener(target, 'click', () => {});
    assert('listener is tracked', mode3._getResourceCounts().listeners === 1);

    mode3.dispose();
    assert('all timers cleared after dispose', mode3._getResourceCounts().timers === 0);
    assert('all rafs cleared after dispose', mode3._getResourceCounts().rafs === 0);
    assert('all listeners cleared after dispose', mode3._getResourceCounts().listeners === 0);

    // --- Lifecycle leak test (mode switching stress) ---
    const testRenderer = renderer;
    const testInput = input;
    const testAudio = audioEngine;
    const testMM = new ModeManager(testInput, testAudio);

    const leakModes = [];
    for (let i = 0; i < 4; i++) {
      const m = new FreePracticeMode(testRenderer, testInput, clock, storage);
      testMM.register('leak' + i, m);
      leakModes.push(m);
    }

    // Switch modes 10 times rapidly
    for (let i = 0; i < 10; i++) {
      await testMM.switchTo('leak' + (i % 4));
    }

    // Check previous modes have zero resources
    let allClean = true;
    const currentModeName = testMM.currentModeName;
    for (let i = 0; i < 4; i++) {
      const m = leakModes[i];
      if ('leak' + i === currentModeName) continue;
      const counts = m._getResourceCounts();
      if (counts.timers !== 0 || counts.rafs !== 0 || counts.listeners !== 0) {
        allClean = false;
        console.log('[LEAK]', 'leak' + i, counts);
      }
    }
    assert('no resource leaks after 10 mode switches', allClean);

    // Current mode should have resources
    const current = testMM.currentMode;
    if (current) {
      const counts = current._getResourceCounts();
      assert('current mode has active resources', counts.rafs > 0 || counts.listeners > 0);
    }

    // Clean up: switch back to main free mode
    current.dispose();

    // --- ModeManager tests ---
    const mm2 = new ModeManager(testInput, testAudio);
    const modeA = new PlaceholderMode('a', 'Mode A');
    const modeB = new PlaceholderMode('b', 'Mode B');
    mm2.register('a', modeA);
    mm2.register('b', modeB);

    assert('currentMode is null before switch', mm2.currentMode === null);

    await mm2.switchTo('a');
    assert('currentModeName is a', mm2.currentModeName === 'a');
    assert('currentMode is modeA', mm2.currentMode === modeA);

    await mm2.switchTo('b');
    assert('currentModeName is b after switch', mm2.currentModeName === 'b');
    assert('modeA is idle after switch away', modeA.state === 'idle');

    // Switch to same mode is no-op
    await mm2.switchTo('b');
    assert('switch to same mode is no-op', mm2.currentModeName === 'b');

    // Unknown mode throws
    let threwError = false;
    try {
      await mm2.switchTo('unknown');
    } catch (e) {
      threwError = true;
    }
    assert('switching to unknown mode throws', threwError);

    // Restore original mode
    await modeManager.switchTo('free');

    return summary('ModeLifecycle Tests');
  }

  function runFreePracticeTests() {
    const { assert, summary } = createTestContext();

    // --- Movement tests ---
    const testFP = new FreePracticeMode(renderer, input, clock, storage);
    testFP._renderer = renderer;
    testFP.enter();

    // Save initial position
    const startX = testFP._scene.character.x;
    const startY = testFP._scene.character.y;

    assert('character starts at center-ish X', startX > 0);
    assert('character starts at lower area Y', startY > 0);

    // Simulate forward movement
    testFP._scene.character.x = 200;
    testFP._scene.character.y = 200;
    const oldY = testFP._scene.character.y;
    // Mock W key pressed
    testFP._inputManager.pressedKeys.add('KeyW');
    testFP._updateMovement(0.1); // 100ms
    assert('W moves character upward (Y decreases)', testFP._scene.character.y < oldY);
    testFP._inputManager.pressedKeys.delete('KeyW');

    // Simulate right movement
    const oldX = testFP._scene.character.x;
    testFP._inputManager.pressedKeys.add('KeyD');
    testFP._updateMovement(0.1);
    assert('D moves character right (X increases)', testFP._scene.character.x > oldX);
    testFP._inputManager.pressedKeys.delete('KeyD');

    // Diagonal movement should be normalized
    testFP._scene.character.x = 200;
    testFP._scene.character.y = 200;
    testFP._inputManager.pressedKeys.add('KeyW');
    testFP._inputManager.pressedKeys.add('KeyD');
    testFP._updateMovement(0.1);
    const diagDx = testFP._scene.character.x - 200;
    const diagDy = 200 - testFP._scene.character.y;
    const diagDist = Math.sqrt(diagDx * diagDx + diagDy * diagDy);
    const straightDist = testFP.MOVE_SPEED * 0.1;
    assert('diagonal movement is normalized', Math.abs(diagDist - straightDist) < 1);
    testFP._inputManager.pressedKeys.delete('KeyW');
    testFP._inputManager.pressedKeys.delete('KeyD');

    // --- Collision tests ---
    // Place character right next to an obstacle
    const obs = testFP._scene.obstacles[0]; // first obstacle
    assert('collision with obstacle is detected',
      testFP._collidesWithObstacle(obs.x + obs.w / 2, obs.y + obs.h / 2));
    assert('no collision when far away',
      !testFP._collidesWithObstacle(0, 0));

    // --- Boundary clamping ---
    testFP._scene.character.x = -50;
    testFP._scene.character.y = -50;
    testFP._clampCharacter();
    assert('X is clamped to minimum', testFP._scene.character.x >= testFP.CHAR_RADIUS);
    assert('Y is clamped to minimum', testFP._scene.character.y >= testFP.CHAR_RADIUS);

    testFP._scene.character.x = 9999;
    testFP._scene.character.y = 9999;
    testFP._clampCharacter();
    const maxX = renderer.width - testFP.CHAR_RADIUS;
    const maxY = renderer.height - testFP.CHAR_RADIUS;
    assert('X is clamped to maximum', testFP._scene.character.x <= maxX);
    assert('Y is clamped to maximum', testFP._scene.character.y <= maxY);

    // --- No movement when keys not pressed ---
    testFP._scene.character.x = 200;
    testFP._scene.character.y = 200;
    testFP._updateMovement(0.1);
    assert('no movement without keys', testFP._scene.character.x === 200 && testFP._scene.character.y === 200);

    // --- Scene has obstacles and enemies ---
    assert('scene has obstacles', testFP._scene.obstacles.length > 0);
    assert('scene has enemies', testFP._scene.enemies.length > 0);

    // --- Warmup guide steps defined ---
    assert('warmup has 6 steps', testFP._warmupSteps.length === 6);

    testFP.dispose();
    input.resetState();

    // Restore original mode
    modeManager.switchTo('free');

    return summary('FreePractice Tests');
  }

  async function runReactionDrillTests() {
    const { assert, summary } = createTestContext();

    // --- Level progression logic ---
    const testStorage = new Storage();
    const testData = testStorage.load();
    // Clear previous reaction data for clean test
    testData.reactionDrill = { levels: {}, best: {} };
    testData.kro = { diagnosis: null, failedCombos: {}, drillFailCounts: {} };

    const drillMode = new ReactionDrillMode(input, clock, testStorage, testData);

    // Test initial state
    assert('drill initial state is idle', drillMode.state === 'idle');

    // Test level unlock logic: level 1 only by default
    drillMode.enter();
    assert('level 1 unlocked by default', drillMode._unlockedLevels.has(1));
    assert('level 2 locked by default', !drillMode._unlockedLevels.has(2));
    assert('level 3 locked by default', !drillMode._unlockedLevels.has(3));

    // Simulate Lv1 completion with fast times (avg < 500ms)
    testData.reactionDrill.levels[1] = { avg: 350, best: 200, timestamp: Date.now() };
    drillMode._loadProgress();
    assert('level 2 unlocked after Lv1 avg < 500ms', drillMode._unlockedLevels.has(2));
    assert('level 3 still locked', !drillMode._unlockedLevels.has(3));

    // Simulate Lv2 completion with fast times
    testData.reactionDrill.levels[2] = { avg: 480, best: 300, timestamp: Date.now() };
    drillMode._loadProgress();
    assert('level 3 unlocked after Lv2 avg < 500ms', drillMode._unlockedLevels.has(3));

    // Simulate slow Lv1 — should not unlock Lv2
    testData.reactionDrill = { levels: {}, best: {} };
    testData.reactionDrill.levels[1] = { avg: 600, best: 450, timestamp: Date.now() };
    drillMode._loadProgress();
    assert('level 2 stays locked with avg > 500ms', !drillMode._unlockedLevels.has(2));

    // --- Question generation ---
    drillMode._currentLevel = 1;
    drillMode._generateQuestions();
    assert('generates 10 questions', drillMode._questions.length === 10);
    assert('Lv1 questions are single key', drillMode._questions.every(q => q.length === 1));

    drillMode._currentLevel = 2;
    drillMode._generateQuestions();
    assert('Lv2 questions are 2-key combos', drillMode._questions.every(q => q.length === 2));

    drillMode._currentLevel = 3;
    drillMode._generateQuestions();
    assert('Lv3 questions are 3-key combos', drillMode._questions.every(q => q.length === 3));

    // --- KRO warning threshold ---
    drillMode._kroAttempts = {};
    drillMode._kroAttempts['KeyA+KeyQ'] = { total: 5, failed: 3 };
    const warnings = drillMode._getKroWarnings();
    assert('KRO warning triggers at 60% fail rate with 5+ attempts', warnings.length === 1);
    assert('KRO warning combo is A+Q', warnings[0] === 'A+Q');

    // Below threshold
    drillMode._kroAttempts['KeyD+KeyE'] = { total: 5, failed: 2 };
    const warnings2 = drillMode._getKroWarnings();
    assert('no KRO warning at 40% fail rate', warnings2.length === 1); // only A+Q

    // Not enough attempts
    drillMode._kroAttempts['KeyW+KeyE'] = { total: 4, failed: 4 };
    const warnings3 = drillMode._getKroWarnings();
    assert('no KRO warning with < 5 attempts', warnings3.length === 1); // still only A+Q

    // --- State transitions ---
    drillMode._currentLevel = 1;
    drillMode.enter();
    assert('state is idle after enter', drillMode.state === 'idle');

    // --- Resource cleanup ---
    drillMode.dispose();
    const counts = drillMode._getResourceCounts();
    assert('all timers cleared after dispose', counts.timers === 0);
    assert('all rafs cleared after dispose', counts.rafs === 0);
    assert('all listeners cleared after dispose', counts.listeners === 0);

    // Restore original mode
    await modeManager.switchTo('free');

    return summary('ReactionDrill Tests');
  }

  async function runComboDrillTests() {
    const { assert, summary } = createTestContext();

    // --- COMBOS data structure ---
    assert('COMBOS has 4 techniques', COMBOS.length === 4);
    assert('jiggle_right is first', COMBOS[0].id === 'jiggle_right');
    assert('strafe_peek_right is second', COMBOS[1].id === 'strafe_peek_right');
    assert('forward_peek_right is third', COMBOS[2].id === 'forward_peek_right');
    assert('alternating_peek is fourth', COMBOS[3].id === 'alternating_peek');

    // --- Step structure ---
    for (const combo of COMBOS) {
      assert(combo.id + ' has steps', combo.steps.length > 0);
      assert(combo.id + ' has repeatCount', combo.repeatCount > 0);
      for (const step of combo.steps) {
        assert(combo.id + ' step has valid action', step.action === 'press' || step.action === 'release');
        assert(combo.id + ' step has keys', step.keys.length > 0);
        assert(combo.id + ' step has maxDuration', step.maxDuration > 0);
        assert(combo.id + ' step has simultaneousWindow defined', typeof step.simultaneousWindow === 'number');
      }
    }

    // --- Unlock logic ---
    const testStorage = new Storage();
    const testData = testStorage.load();
    testData.comboDrill = { techniques: {}, unlocked: ['jiggle_right'] };

    const drillMode = new ComboDrillMode(input, clock, testStorage, testData);
    drillMode.enter();

    assert('jiggle_right unlocked by default', drillMode._unlockedCombos.has('jiggle_right'));
    assert('strafe_peek_right locked by default', !drillMode._unlockedCombos.has('strafe_peek_right'));
    assert('forward_peek_right locked by default', !drillMode._unlockedCombos.has('forward_peek_right'));
    assert('alternating_peek locked by default', !drillMode._unlockedCombos.has('alternating_peek'));

    // Simulate jiggle_right success >= 80%
    testData.comboDrill.techniques['jiggle_right'] = { successRate: 0.85, attempts: 3 };
    drillMode._loadProgress();
    assert('strafe_peek_right unlocked after jiggle 85%', drillMode._unlockedCombos.has('strafe_peek_right'));
    assert('forward_peek_right still locked', !drillMode._unlockedCombos.has('forward_peek_right'));

    // Simulate strafe_peek_right success >= 80%
    testData.comboDrill.techniques['strafe_peek_right'] = { successRate: 0.80, attempts: 5 };
    drillMode._loadProgress();
    assert('forward_peek_right unlocked after strafe 80%', drillMode._unlockedCombos.has('forward_peek_right'));
    assert('alternating_peek still locked', !drillMode._unlockedCombos.has('alternating_peek'));

    // Below threshold — should not unlock
    testData.comboDrill.techniques['forward_peek_right'] = { successRate: 0.75, attempts: 4 };
    drillMode._loadProgress();
    assert('alternating_peek locked at 75%', !drillMode._unlockedCombos.has('alternating_peek'));

    // At threshold
    testData.comboDrill.techniques['forward_peek_right'] = { successRate: 0.80, attempts: 5 };
    drillMode._loadProgress();
    assert('alternating_peek unlocked at 80%', drillMode._unlockedCombos.has('alternating_peek'));

    // --- Key resolution with lean direction ---
    // Default (reversed): Q=right, E=left → swap KeyQ↔KeyE
    input.setLeanDirection(false);
    assert('Reversed: _resolveKey(KeyQ) → KeyE', drillMode._resolveKey('KeyQ') === 'KeyE');
    assert('Reversed: _resolveKey(KeyE) → KeyQ', drillMode._resolveKey('KeyE') === 'KeyQ');
    assert('Reversed: _resolveKey(KeyD) → KeyD', drillMode._resolveKey('KeyD') === 'KeyD');

    const reversedKeys = drillMode._resolveStepKeys(['KeyD', 'KeyE']);
    assert('Reversed: [KeyD, KeyE] → [KeyD, KeyQ]', reversedKeys[0] === 'KeyD' && reversedKeys[1] === 'KeyQ');

    // EFT Standard: no swap
    input.setLeanDirection(true);
    assert('Standard: _resolveKey(KeyQ) → KeyQ', drillMode._resolveKey('KeyQ') === 'KeyQ');
    assert('Standard: _resolveKey(KeyE) → KeyE', drillMode._resolveKey('KeyE') === 'KeyE');

    const standardKeys = drillMode._resolveStepKeys(['KeyD', 'KeyE']);
    assert('Standard: [KeyD, KeyE] → [KeyD, KeyE]', standardKeys[0] === 'KeyD' && standardKeys[1] === 'KeyE');

    // Reset to default
    input.setLeanDirection(false);

    // --- State transitions ---
    drillMode._selectedCombo = COMBOS[0];
    assert('state is idle after enter', drillMode.state === 'idle');

    // --- Resource cleanup ---
    drillMode.dispose();
    const counts = drillMode._getResourceCounts();
    assert('all timers cleared after dispose', counts.timers === 0);
    assert('all rafs cleared after dispose', counts.rafs === 0);
    assert('all listeners cleared after dispose', counts.listeners === 0);

    // Restore original mode
    await modeManager.switchTo('free');

    return summary('ComboDrill Tests');
  }

  async function runRhythmDrillTests() {
    const { assert, summary } = createTestContext();

    const testStorage = new Storage();
    const testData = testStorage.load();
    testData.rhythmDrill = { maxBPM: 60, perfectRate: 0, attempts: 0 };

    const drillMode = new RhythmDrillMode(input, audioEngine, clock, testStorage, testData);
    drillMode.enter();

    // --- Constants ---
    assert('BPM_MIN is 60', RhythmDrillMode.BPM_MIN === 60);
    assert('BPM_MAX is 180', RhythmDrillMode.BPM_MAX === 180);
    assert('BPM_DEFAULT is 100', RhythmDrillMode.BPM_DEFAULT === 100);
    assert('PERFECT_THRESHOLD_MS is 40', RhythmDrillMode.PERFECT_THRESHOLD_MS === 40);
    assert('GOOD_THRESHOLD_MS is 90', RhythmDrillMode.GOOD_THRESHOLD_MS === 90);
    assert('WARMUP_BEATS is 4', RhythmDrillMode.WARMUP_BEATS === 4);
    assert('BEATS_PER_SET is 16', RhythmDrillMode.BEATS_PER_SET === 16);
    assert('BPM_ADVANCE_RATE is 0.8', RhythmDrillMode.BPM_ADVANCE_RATE === 0.8);

    // --- Pattern ---
    assert('pattern length is 4', drillMode._pattern.length === 4);
    assert('pattern[0] is right', drillMode._pattern[0] === 'right');
    assert('pattern[1] is neutral', drillMode._pattern[1] === 'neutral');
    assert('pattern[2] is left', drillMode._pattern[2] === 'left');
    assert('pattern[3] is neutral', drillMode._pattern[3] === 'neutral');

    // --- State ---
    assert('initial state is idle', drillMode.state === 'idle');
    assert('currentBPM defaults to BPM_DEFAULT', drillMode._currentBPM === RhythmDrillMode.BPM_DEFAULT);
    assert('progressive BPM off by default', drillMode._progressiveBPM === false);

    // --- Beat schedule ---
    drillMode._currentBPM = 120;
    drillMode._timeOffset = 0;
    drillMode._beatTimes = [];
    // Simulate beat schedule generation
    const totalBeats = RhythmDrillMode.WARMUP_BEATS + RhythmDrillMode.BEATS_PER_SET;
    assert('total beats is 20', totalBeats === 20);

    // --- Timing judgment logic ---
    // Simulate results and check judgment boundaries
    drillMode._results = [];
    drillMode._recordResult(4, 'perfect', 30);
    drillMode._recordResult(5, 'good', 70);
    drillMode._recordResult(6, 'miss', 120);
    assert('3 results recorded', drillMode._results.length === 3);
    assert('perfect at 30ms', drillMode._results[0].judgment === 'perfect');
    assert('good at 70ms', drillMode._results[1].judgment === 'good');
    assert('miss at 120ms', drillMode._results[2].judgment === 'miss');

    // --- Threshold boundary values ---
    // Perfect: ±40ms boundary
    assert('39ms is within perfect', 39 <= RhythmDrillMode.PERFECT_THRESHOLD_MS);
    assert('40ms is within perfect', 40 <= RhythmDrillMode.PERFECT_THRESHOLD_MS);
    assert('41ms exceeds perfect', 41 > RhythmDrillMode.PERFECT_THRESHOLD_MS);

    // Good: ±90ms boundary
    assert('89ms is within good', 89 <= RhythmDrillMode.GOOD_THRESHOLD_MS);
    assert('90ms is within good', 90 <= RhythmDrillMode.GOOD_THRESHOLD_MS);
    assert('91ms exceeds good', 91 > RhythmDrillMode.GOOD_THRESHOLD_MS);

    // --- Progress persistence ---
    drillMode._results = [];
    for (let i = 0; i < 16; i++) {
      drillMode._recordResult(i + 4, i < 14 ? 'perfect' : 'good', i < 14 ? 20 : 60);
    }
    drillMode._currentBPM = 60;
    drillMode._saveProgress();
    const savedData = testData.rhythmDrill;
    assert('progress saved with attempts', savedData.attempts === 1);
    assert('maxBPM advanced (100% success >= 80%)', savedData.maxBPM >= 70);
    assert('perfectRate calculated', savedData.perfectRate > 0);

    // --- Resource cleanup ---
    drillMode.dispose();
    const counts = drillMode._getResourceCounts();
    assert('all timers cleared after dispose', counts.timers === 0);
    assert('all rafs cleared after dispose', counts.rafs === 0);
    assert('all listeners cleared after dispose', counts.listeners === 0);

    // Restore original mode
    await modeManager.switchTo('free');

    return summary('RhythmDrill Tests');
  }

  function runInputTransitionTests() {
    const { assert, summary } = createTestContext();

    // Note: InputManager registers global keydown/keyup listeners on construction.
    // Tests access _updateLeanState directly, bypassing event dispatch.
    const testInput = new InputManager();

    // === Hold Mode (8 patterns) — EFT Standard layout (Q=left, E=right) ===
    // Key order mirrors production: keydown → pressedKeys.add → _updateLeanState
    testInput.setLeanDirection(true); // EFT standard for legacy tests
    testInput.setLeanMode('hold');

    // Pattern 1: neutral + Q keydown → left
    testInput.leanState = 'neutral';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyQ');
    testInput._updateLeanState('KeyQ', 'keydown');
    assert('Hold: neutral + Q down → left', testInput.leanState === 'left');

    // Pattern 2: neutral + E keydown → right
    testInput.leanState = 'neutral';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyE');
    testInput._updateLeanState('KeyE', 'keydown');
    assert('Hold: neutral + E down → right', testInput.leanState === 'right');

    // Pattern 3: left + Q keyup → neutral
    testInput.leanState = 'left';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyQ');
    testInput.pressedKeys.delete('KeyQ');
    testInput._updateLeanState('KeyQ', 'keyup');
    assert('Hold: left + Q up → neutral', testInput.leanState === 'neutral');

    // Pattern 4: left + E keydown → right (last-key-wins)
    testInput.leanState = 'left';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyQ');
    testInput.pressedKeys.add('KeyE');
    testInput._updateLeanState('KeyE', 'keydown');
    assert('Hold: left + E down → right', testInput.leanState === 'right');

    // Pattern 5: right + E keyup → neutral
    testInput.leanState = 'right';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyE');
    testInput.pressedKeys.delete('KeyE');
    testInput._updateLeanState('KeyE', 'keyup');
    assert('Hold: right + E up → neutral', testInput.leanState === 'neutral');

    // Pattern 6: right + Q keydown → left (last-key-wins)
    testInput.leanState = 'right';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyE');
    testInput.pressedKeys.add('KeyQ');
    testInput._updateLeanState('KeyQ', 'keydown');
    assert('Hold: right + Q down → left', testInput.leanState === 'left');

    // Pattern 7: left (Q+E held) + Q keyup → right (E remains)
    testInput.leanState = 'left';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyQ');
    testInput.pressedKeys.add('KeyE');
    testInput.pressedKeys.delete('KeyQ');
    testInput._updateLeanState('KeyQ', 'keyup');
    assert('Hold: left(Q+E) + Q up → right', testInput.leanState === 'right');

    // Pattern 8: right (Q+E held) + E keyup → left (Q remains)
    testInput.leanState = 'right';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyQ');
    testInput.pressedKeys.add('KeyE');
    testInput.pressedKeys.delete('KeyE');
    testInput._updateLeanState('KeyE', 'keyup');
    assert('Hold: right(Q+E) + E up → left', testInput.leanState === 'left');

    // === Toggle Mode (6 patterns) ===
    testInput.setLeanMode('toggle');

    // Pattern 1: neutral + Q → left
    testInput.leanState = 'neutral';
    testInput._updateLeanState('KeyQ', 'keydown');
    assert('Toggle: neutral + Q → left', testInput.leanState === 'left');

    // Pattern 2: neutral + E → right
    testInput.leanState = 'neutral';
    testInput._updateLeanState('KeyE', 'keydown');
    assert('Toggle: neutral + E → right', testInput.leanState === 'right');

    // Pattern 3: left + Q → neutral (same key cancels)
    testInput.leanState = 'left';
    testInput._updateLeanState('KeyQ', 'keydown');
    assert('Toggle: left + Q → neutral', testInput.leanState === 'neutral');

    // Pattern 4: left + E → right (opposite key switches)
    testInput.leanState = 'left';
    testInput._updateLeanState('KeyE', 'keydown');
    assert('Toggle: left + E → right', testInput.leanState === 'right');

    // Pattern 5: right + E → neutral (same key cancels)
    testInput.leanState = 'right';
    testInput._updateLeanState('KeyE', 'keydown');
    assert('Toggle: right + E → neutral', testInput.leanState === 'neutral');

    // Pattern 6: right + Q → left (opposite key switches)
    testInput.leanState = 'right';
    testInput._updateLeanState('KeyQ', 'keydown');
    assert('Toggle: right + Q → left', testInput.leanState === 'left');

    // === Reversed Direction (default: Q=right, E=left) ===
    testInput.setLeanDirection(false);
    testInput.setLeanMode('hold');

    // Reversed Hold: Q keydown → right (not left)
    testInput.leanState = 'neutral';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyQ');
    testInput._updateLeanState('KeyQ', 'keydown');
    assert('Reversed Hold: Q down → right', testInput.leanState === 'right');

    // Reversed Hold: E keydown → left (not right)
    testInput.leanState = 'neutral';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyE');
    testInput._updateLeanState('KeyE', 'keydown');
    assert('Reversed Hold: E down → left', testInput.leanState === 'left');

    // Reversed Hold: Q keyup with E held → left
    testInput.leanState = 'right';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyQ');
    testInput.pressedKeys.add('KeyE');
    testInput.pressedKeys.delete('KeyQ');
    testInput._updateLeanState('KeyQ', 'keyup');
    assert('Reversed Hold: right(Q+E) + Q up → left', testInput.leanState === 'left');

    // Reversed Toggle: Q → right
    testInput.setLeanMode('toggle');
    testInput.leanState = 'neutral';
    testInput._updateLeanState('KeyQ', 'keydown');
    assert('Reversed Toggle: neutral + Q → right', testInput.leanState === 'right');

    // Reversed Toggle: E → left
    testInput.leanState = 'neutral';
    testInput._updateLeanState('KeyE', 'keydown');
    assert('Reversed Toggle: neutral + E → left', testInput.leanState === 'left');

    // Reversed Toggle: right + Q → neutral (same direction cancels)
    testInput.leanState = 'right';
    testInput._updateLeanState('KeyQ', 'keydown');
    assert('Reversed Toggle: right + Q → neutral', testInput.leanState === 'neutral');

    // === EFT Standard Direction (Q=left, E=right) ===
    testInput.setLeanDirection(true);
    testInput.setLeanMode('hold');

    testInput.leanState = 'neutral';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyQ');
    testInput._updateLeanState('KeyQ', 'keydown');
    assert('EFT Standard Hold: Q down → left', testInput.leanState === 'left');

    testInput.leanState = 'neutral';
    testInput.pressedKeys.clear();
    testInput.pressedKeys.add('KeyE');
    testInput._updateLeanState('KeyE', 'keydown');
    assert('EFT Standard Hold: E down → right', testInput.leanState === 'right');

    // === getLeanKeyForDirection ===
    testInput.setLeanDirection(false); // reversed
    assert('Reversed: right key is KeyQ', testInput.getLeanKeyForDirection('right') === 'KeyQ');
    assert('Reversed: left key is KeyE', testInput.getLeanKeyForDirection('left') === 'KeyE');

    testInput.setLeanDirection(true); // standard
    assert('Standard: left key is KeyQ', testInput.getLeanKeyForDirection('left') === 'KeyQ');
    assert('Standard: right key is KeyE', testInput.getLeanKeyForDirection('right') === 'KeyE');

    // === getKeySymbol ===
    testInput.setLeanDirection(false); // reversed: Q=right, E=left
    assert('Reversed: KeyW symbol is ↑', testInput.getKeySymbol('KeyW') === '↑');
    assert('Reversed: KeyA symbol is ←', testInput.getKeySymbol('KeyA') === '←');
    assert('Reversed: KeyS symbol is ↓', testInput.getKeySymbol('KeyS') === '↓');
    assert('Reversed: KeyD symbol is →', testInput.getKeySymbol('KeyD') === '→');
    assert('Reversed: KeyQ symbol is ↷ (right)', testInput.getKeySymbol('KeyQ') === '↷');
    assert('Reversed: KeyE symbol is ↶ (left)', testInput.getKeySymbol('KeyE') === '↶');

    testInput.setLeanDirection(true); // standard: Q=left, E=right
    assert('Standard: KeyQ symbol is ↶ (left)', testInput.getKeySymbol('KeyQ') === '↶');
    assert('Standard: KeyE symbol is ↷ (right)', testInput.getKeySymbol('KeyE') === '↷');

    // Cleanup
    testInput.destroy();

    return summary('Input Transition Tests');
  }

  function runSimultaneousJudgmentTests() {
    const { assert, summary } = createTestContext();

    const testInput = new InputManager();
    const now = performance.now();
    // Threshold should match InputManager.SIMULTANEOUS_THRESHOLD_MS (80ms)
    const THRESHOLD = 80;

    // Test 1: 79ms apart = simultaneous (within threshold)
    testInput._keyPressTimestamps.clear();
    testInput._keyPressTimestamps.set('KeyD', now);
    testInput._keyPressTimestamps.set('KeyE', now + THRESHOLD - 1);
    assert('79ms apart is simultaneous', testInput.areSimultaneous(['KeyD', 'KeyE']));

    // Test 2: 80ms apart = simultaneous (at boundary)
    testInput._keyPressTimestamps.clear();
    testInput._keyPressTimestamps.set('KeyD', now);
    testInput._keyPressTimestamps.set('KeyE', now + THRESHOLD);
    assert('80ms apart is simultaneous (boundary)', testInput.areSimultaneous(['KeyD', 'KeyE']));

    // Test 3: 81ms apart = not simultaneous
    testInput._keyPressTimestamps.clear();
    testInput._keyPressTimestamps.set('KeyD', now);
    testInput._keyPressTimestamps.set('KeyE', now + THRESHOLD + 1);
    assert('81ms apart is NOT simultaneous', !testInput.areSimultaneous(['KeyD', 'KeyE']));

    // Test 4: 3 keys all within window
    testInput._keyPressTimestamps.clear();
    testInput._keyPressTimestamps.set('KeyW', now);
    testInput._keyPressTimestamps.set('KeyD', now + 30);
    testInput._keyPressTimestamps.set('KeyE', now + 60);
    assert('3 keys within 60ms is simultaneous', testInput.areSimultaneous(['KeyW', 'KeyD', 'KeyE']));

    // Test 5: 3 keys exceeding window
    testInput._keyPressTimestamps.clear();
    testInput._keyPressTimestamps.set('KeyW', now);
    testInput._keyPressTimestamps.set('KeyD', now + 40);
    testInput._keyPressTimestamps.set('KeyE', now + THRESHOLD + 1);
    assert('3 keys spanning 81ms is NOT simultaneous', !testInput.areSimultaneous(['KeyW', 'KeyD', 'KeyE']));

    // Test 6: missing key returns false
    testInput._keyPressTimestamps.clear();
    testInput._keyPressTimestamps.set('KeyD', now);
    assert('missing key returns false', !testInput.areSimultaneous(['KeyD', 'KeyE']));

    // Test 7: empty array returns false
    assert('empty array returns false', !testInput.areSimultaneous([]));

    // Test 8: single key is always simultaneous
    testInput._keyPressTimestamps.clear();
    testInput._keyPressTimestamps.set('KeyW', now);
    assert('single key is simultaneous', testInput.areSimultaneous(['KeyW']));

    testInput.destroy();

    return summary('Simultaneous Judgment Tests');
  }

  function runRaycastTests() {
    const { assert, summary } = createTestContext();

    // Uses the app-level renderer instance for geometry tests.
    // Renderer methods under test are pure computation with no side effects,
    // so sharing the instance is safe.
    const testRenderer = renderer;

    // Test 1: _isInFOV - target directly in front (upward direction = -PI/2)
    const frontAngle = -Math.PI / 2;
    assert('target directly above is in FOV',
      testRenderer._isInFOV(200, 300, 200, 100, frontAngle));

    // Test 2: target behind (below)
    assert('target directly below is NOT in FOV',
      !testRenderer._isInFOV(200, 300, 200, 500, frontAngle));

    // Test 3: target at edge of FOV (30 degrees = PI/6)
    const edgeX = 200 + 200 * Math.sin(Math.PI / 6);
    const edgeY = 300 - 200 * Math.cos(Math.PI / 6);
    assert('target at FOV edge is in FOV',
      testRenderer._isInFOV(200, 300, edgeX, edgeY, frontAngle));

    // Test 4: target just outside FOV
    const outsideX = 200 + 200 * Math.sin(Math.PI / 6 + 0.1);
    const outsideY = 300 - 200 * Math.cos(Math.PI / 6 + 0.1);
    assert('target just outside FOV is NOT in FOV',
      !testRenderer._isInFOV(200, 300, outsideX, outsideY, frontAngle));

    // Test 5: _rayAABBIntersect - ray hitting an obstacle
    const obstacle = { x: 180, y: 150, w: 40, h: 20 };
    const hitDist = testRenderer._rayAABBIntersect(200, 300, 0, -1, obstacle);
    assert('ray hits obstacle (finite distance)', hitDist !== Infinity && hitDist > 0);
    assert('ray hit distance is correct', Math.abs(hitDist - 130) < 1);

    // Test 6: ray missing an obstacle (horizontal ray misses vertical obstacle)
    const missDist = testRenderer._rayAABBIntersect(200, 300, 1, 0, obstacle);
    assert('ray misses obstacle (infinite distance)', missDist === Infinity);

    // Test 7: _getFrontAngle always returns -PI/2 (lean uses roll, not yaw)
    assert('_getFrontAngle returns -PI/2',
      Math.abs(testRenderer._getFrontAngle() - (-Math.PI / 2)) < testRenderer.EPSILON);

    // Test 8: _clampCameraToObstacles - camera outside obstacle is unchanged
    const char8 = { x: 200, y: 300 };
    const obs8 = { x: 100, y: 100, w: 50, h: 50 };
    const vp8 = { x: 220, y: 300 };
    const clamped8 = testRenderer._clampCameraToObstacles(vp8, char8, [obs8]);
    assert('camera outside obstacle is unchanged', clamped8.x === 220 && clamped8.y === 300);

    // Test 9: _clampCameraToObstacles - camera inside obstacle is clamped out
    const char9 = { x: 200, y: 300 };
    const obs9 = { x: 210, y: 295, w: 40, h: 10 };
    const vp9 = { x: 220, y: 300 }; // inside obs9 (x:210-250, y:295-305)
    const clamped9 = testRenderer._clampCameraToObstacles(vp9, char9, [obs9]);
    const stillInside9 = clamped9.x > obs9.x && clamped9.x < obs9.x + obs9.w &&
                         clamped9.y > obs9.y && clamped9.y < obs9.y + obs9.h;
    assert('camera clamped out of obstacle', !stillInside9);

    // Test 10: fish-eye correction formula - perpDist = hitDist * cos(angleDiff)
    const angOffset = Math.PI / 6; // 30° from front = edge of FOV
    const hitD = 100;
    const expectedPerp = hitD * Math.cos(angOffset); // ~86.6
    assert('fish-eye perpDist formula is correct', Math.abs(expectedPerp - 86.6) < 0.1);

    return summary('Raycast Tests');
  }

  function runStorageTests() {
    const { assert, summary } = createTestContext();

    const testStore = new Storage();

    // Use a test key to avoid corrupting real data
    testStore.KEY = 'eft-lean-trainer-test-' + Date.now();
    testStore.BACKUP_PREFIX = testStore.KEY + '-backup-';

    function cleanupTestKeys() {
      localStorage.removeItem(testStore.KEY);
      for (let i = localStorage.length - 1; i >= 0; i--) {
        const key = localStorage.key(i);
        if (key && key.startsWith(testStore.BACKUP_PREFIX)) {
          localStorage.removeItem(key);
        }
      }
    }

    try {
      // Test 1: load returns defaults when no data
      localStorage.removeItem(testStore.KEY);
      const defaults = testStore.load();
      assert('load returns defaults when empty', defaults.schemaVersion === 2);
      assert('defaults have settings', defaults.settings && defaults.settings.leanMode === 'hold');
      assert('defaults have useEftStandard', defaults.settings.useEftStandard === false);
      assert('defaults have kro', defaults.kro !== undefined);

      // Test 2: save and load roundtrip
      defaults.settings.leanMode = 'toggle';
      testStore.save(defaults);
      const loaded = testStore.load();
      assert('save/load roundtrip preserves data', loaded.settings.leanMode === 'toggle');

      // Test 3: clear removes data
      testStore.save(defaults);
      testStore.clear();
      const afterClear = testStore.load();
      assert('clear resets to defaults', afterClear.settings.leanMode === 'hold');

      // Test 4: corrupted JSON fallback
      localStorage.setItem(testStore.KEY, '{invalid json!!!');
      const recovered = testStore.load();
      assert('corrupted data returns defaults', recovered.schemaVersion === 2);
      assert('corrupted data resets leanMode', recovered.settings.leanMode === 'hold');

      // Verify backup was created
      let backupFound = false;
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(testStore.BACKUP_PREFIX)) {
          backupFound = true;
          localStorage.removeItem(key);
        }
      }
      assert('backup created for corrupted data', backupFound);

      // Test 5: future schema version is read-only
      const futureData = JSON.stringify({ schemaVersion: 999, settings: { leanMode: 'toggle' } });
      localStorage.setItem(testStore.KEY, futureData);
      const futureLoaded = testStore.load();
      assert('future schema is read-only', futureLoaded._readOnly === true);
      assert('future schema preserves data', futureLoaded.settings.leanMode === 'toggle');

      // Test 6: save is no-op for read-only data
      futureLoaded.settings.leanMode = 'hold';
      testStore.save(futureLoaded);
      const afterSave = JSON.parse(localStorage.getItem(testStore.KEY));
      assert('read-only data is not overwritten', afterSave.settings.leanMode === 'toggle');

      // Test 7: migration map executes (uses isolated Storage instance with test key)
      const migrateStore = new Storage();
      migrateStore.KEY = 'eft-lean-trainer-migrate-test-' + Date.now();
      migrateStore.CURRENT_VERSION = 3;
      migrateStore.MIGRATIONS = {
        1: function(data) {
          if (!data.settings) data.settings = {};
          if (data.settings.useEftStandard === undefined) data.settings.useEftStandard = false;
          data.schemaVersion = 2;
          return data;
        },
        2: function(data) {
          data.newField = 'migrated';
          data.schemaVersion = 3;
          return data;
        }
      };
      const v1Data = { schemaVersion: 1, settings: { leanMode: 'hold' } };
      const migrated = migrateStore.migrate(v1Data);
      assert('migration updates version', migrated.schemaVersion === 3);
      assert('migration adds new field', migrated.newField === 'migrated');
      assert('migration adds useEftStandard', migrated.settings.useEftStandard === false);
      localStorage.removeItem(migrateStore.KEY);

      // Test 7b: v1→v2 migration adds useEftStandard
      const v1to2Data = { schemaVersion: 1, settings: { leanMode: 'toggle' } };
      const migratedV2 = testStore.migrate(v1to2Data);
      assert('v1→v2 migration sets version to 2', migratedV2.schemaVersion === 2);
      assert('v1→v2 migration adds useEftStandard', migratedV2.settings.useEftStandard === false);
      assert('v1→v2 migration preserves leanMode', migratedV2.settings.leanMode === 'toggle');

      // Test 7c: v1 data without settings object
      const v1NoSettings = { schemaVersion: 1 };
      const migratedNoSettings = testStore.migrate(v1NoSettings);
      assert('v1→v2 creates settings if missing', migratedNoSettings.settings !== undefined);
      assert('v1→v2 adds useEftStandard to new settings', migratedNoSettings.settings.useEftStandard === false);

      // Test 8: invalid schemaVersion triggers fallback
      localStorage.setItem(testStore.KEY, JSON.stringify({ schemaVersion: -1 }));
      const invalidSchema = testStore.load();
      assert('invalid schema version triggers fallback', invalidSchema.schemaVersion === 2);

      // Test 9: non-integer schemaVersion triggers fallback
      localStorage.setItem(testStore.KEY, JSON.stringify({ schemaVersion: 1.5 }));
      const floatSchema = testStore.load();
      assert('float schema version triggers fallback', floatSchema.schemaVersion === 2);

    } finally {
      cleanupTestKeys();
    }

    return summary('Storage Tests');
  }

  async function runAudioResumeFailureTests() {
    const { assert, summary } = createTestContext();

    // Test AudioEngine resume failure handling
    const testEngine = new AudioEngine();

    try {
      await testEngine.init();

      // Mock resume to reject
      const origCtx = testEngine._ctx;
      const origResume = origCtx.resume.bind(origCtx);

      // Force suspend first
      await testEngine.suspend();
      assert('engine is suspended', testEngine.state === 'suspended');

      // Replace resume with one that rejects
      origCtx.resume = () => Promise.reject(new Error('Mock resume failure'));

      try {
        await testEngine.resume();
        // If resume catches the error internally, state should still be suspended
        assert('resume failure keeps engine suspended or handles gracefully',
          testEngine.state === 'suspended' || testEngine.lastError !== null);
      } catch (e) {
        // Resume threw — that's also acceptable
        assert('resume failure throws error', e.message === 'Mock resume failure');
        assert('state remains suspended after failure', testEngine.state === 'suspended');
      }

      // Restore original resume
      origCtx.resume = origResume;
      await testEngine.resume();
      assert('resume works after restoring', testEngine.state === 'running');

    } catch (e) {
      // AudioContext may not be available without user gesture in some environments.
      // This is an environment limitation, not a test failure — skip gracefully.
      console.warn('AudioEngine resume test skipped: ' + e.message);
    }

    testEngine.destroy();

    return summary('AudioEngine Resume Failure Tests');
  }

  // Note: Test functions (runInputTransitionTests, runSimultaneousJudgmentTests, etc.)
  // each follow the same createTestContext() + assert() + summary() pattern.
  // This repetition is intentional — each test is self-contained and independently runnable
  // from the console, which is more valuable than DRY abstraction for a debugging tool.
  //
  // Tests access private members (_updateLeanState, _keyPressTimestamps, etc.) directly.
  // This is acceptable for self-test functions that verify internal state transitions;
  // they are tightly coupled to the implementation by design.

  async function runTests() {
    console.log('=== EFT Trainer Self-Tests ===');
    const audioResults = await runAudioEngineTests();
    const modeResults = await runModeLifecycleTests();
    const fpResults = runFreePracticeTests();
    const reactionResults = await runReactionDrillTests();
    const comboResults = await runComboDrillTests();
    const rhythmResults = await runRhythmDrillTests();
    const inputResults = runInputTransitionTests();
    const simultaneousResults = runSimultaneousJudgmentTests();
    const raycastResults = runRaycastTests();
    const storageResults = runStorageTests();
    const audioResumeResults = await runAudioResumeFailureTests();

    const allResults = [audioResults, modeResults, fpResults, reactionResults, comboResults, rhythmResults, inputResults, simultaneousResults, raycastResults, storageResults, audioResumeResults];
    const totalPassed = allResults.reduce((sum, r) => sum + r.passed, 0);
    const totalTests = allResults.reduce((sum, r) => sum + r.total, 0);
    console.log('=== Total: ' + totalPassed + '/' + totalTests + ' passed ===');
    return {
      audioResults, modeResults, fpResults, reactionResults, comboResults, rhythmResults,
      inputResults, simultaneousResults, raycastResults, storageResults, audioResumeResults,
      totalPassed, totalTests
    };
  }

  // --- Expose minimal public API ---
  window.EFTTrainer = Object.freeze({
    modeManager,
    runTests,
    destroy() {
      if (modeManager.currentMode) {
        modeManager.currentMode.dispose();
      }
      renderer.destroy();
      audioEngine.destroy();
    }
  });
})();
</script>

</body>
</html>
